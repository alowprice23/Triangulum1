#!/usr/bin/env python3
"""
Repair Tool Command-Line Interface

This script provides a command-line interface for the Repair Tool
functionality in Triangulum. It allows users to plan and apply repairs to a codebase.
"""

import argparse
import logging
import sys
import os
import json
from pathlib import Path

# Add the project root to the Python path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from triangulum_lx.tooling.repair import RepairTool, FileChange, RepairPlan

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("repair_tool")

def plan_repairs(args):
    """
    Plan repairs for a codebase.
    
    Args:
        args: Command-line arguments
    """
    target_path = Path(args.path)
    
    if not target_path.exists():
        logger.error(f"Path does not exist: {target_path}")
        return 1
    
    logger.info(f"Planning repairs for {target_path}")
    
    # Create a repair tool
    repair_tool = RepairTool()
    
    # Get bugs from the bug detector
    from triangulum_lx.agents.bug_detector_agent import BugDetectorAgent
    bug_detector = BugDetectorAgent(agent_id="bug_detector_cli", root_path=str(project_root))
    
    if target_path.is_file():
        # Scan a single file
        bugs = bug_detector.detect_bugs_in_file(
            file_path=str(target_path),
            verify_bugs=True
        )
    else:
        # Scan a directory
        result = bug_detector.detect_bugs_in_folder(
            folder_path=str(target_path),
            recursive=True
        )
        bugs = []
        if 'bugs_by_file' in result:
            for file_path, file_bugs in result['bugs_by_file'].items():
                for bug in file_bugs:
                    bugs.append(bug)
    
    # Create repair plans for each bug
    repair_plans = []
    for bug in bugs:
        # Create a file change for the bug
        file_path = bug.file_path
        if not file_path:
            continue
        
        # Read the file content
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception as e:
            logger.error(f"Error reading file {file_path}: {e}")
            continue
        
        # Get the line number
        line_number = bug.line_number
        if not line_number:
            continue
        
        # Create a file change
        lines = content.splitlines()
        start_line = max(1, line_number)
        end_line = min(len(lines), line_number + 1)
        
        # Get the original content
        original_content = "\n".join(lines[start_line-1:end_line])
        
        # Create a placeholder for the new content
        # In a real implementation, this would be generated by an LLM
        new_content = f"# Fixed: {bug.bug_type.value} - {bug.description}\n{original_content}"
        
        file_change = FileChange(
            file_path=file_path,
            start_line=start_line,
            end_line=end_line,
            original_content=original_content,
            new_content=new_content,
            change_type="replace",
            metadata={"bug": bug}
        )
        
        # Create a repair plan
        repair_plan = repair_tool.create_repair_plan(
            name=f"Fix {bug.bug_type.value} in {file_path}",
            description=bug.description,
            changes=[file_change],
            metadata={"bug": bug.to_dict()}
        )
        
        repair_plans.append(repair_plan)
    
    # Print the repair plans
    print(f"\n=== Repair Plans ({len(repair_plans)}) ===")
    for i, plan in enumerate(repair_plans, 1):
        print(f"\nRepair Plan #{i}: {plan.name}")
        print(f"  ID: {plan.id}")
        print(f"  Description: {plan.description}")
        print(f"  Affected Files: {', '.join(plan.get_affected_files())}")
        print(f"  Changes: {len(plan.changes)}")
    
    # Save the repair plans to a file if requested
    if args.output:
        # Convert repair plans to a serializable format
        serializable_plans = []
        for plan in repair_plans:
            serializable_plan = {
                "id": plan.id,
                "name": plan.name,
                "description": plan.description,
                "affected_files": list(plan.get_affected_files()),
                "changes": [
                    {
                        "file_path": change.file_path,
                        "start_line": change.start_line,
                        "end_line": change.end_line,
                        "change_type": change.change_type,
                        "diff": change.get_diff()
                    }
                    for change in plan.changes
                ]
            }
            serializable_plans.append(serializable_plan)
        
        with open(args.output, 'w') as f:
            json.dump(serializable_plans, f, indent=2)
        
        logger.info(f"Saved repair plans to {args.output}")
    
    return 0

def apply_repairs(args):
    """
    Apply repairs to a codebase.
    
    Args:
        args: Command-line arguments
    """
    target_path = Path(args.path)
    
    if not target_path.exists():
        logger.error(f"Path does not exist: {target_path}")
        return 1
    
    logger.info(f"Applying repairs to {target_path}")
    
    # Create a repair tool
    repair_tool = RepairTool()
    
    # Load repair plans from a file if provided
    if args.plans:
        try:
            with open(args.plans, 'r') as f:
                serialized_plans = json.load(f)
            
            # Convert serialized plans to RepairPlan objects
            repair_plans = []
            for plan_data in serialized_plans:
                changes = []
                for change_data in plan_data.get('changes', []):
                    # Read the file content
                    file_path = change_data.get('file_path')
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                    except Exception as e:
                        logger.error(f"Error reading file {file_path}: {e}")
                        continue
                    
                    # Get the original content
                    lines = content.splitlines()
                    start_line = change_data.get('start_line', 1)
                    end_line = change_data.get('end_line', len(lines))
                    original_content = "\n".join(lines[start_line-1:end_line])
                    
                    # Create a file change
                    file_change = FileChange(
                        file_path=file_path,
                        start_line=start_line,
                        end_line=end_line,
                        original_content=original_content,
                        new_content=change_data.get('new_content', original_content),
                        change_type=change_data.get('change_type', 'replace'),
                        metadata={}
                    )
                    changes.append(file_change)
                
                # Create a repair plan
                repair_plan = repair_tool.create_repair_plan(
                    name=plan_data.get('name', 'Unnamed repair'),
                    description=plan_data.get('description', 'No description provided'),
                    changes=changes,
                    metadata={}
                )
                repair_plans.append(repair_plan)
            
            logger.info(f"Loaded {len(repair_plans)} repair plans from {args.plans}")
        except Exception as e:
            logger.error(f"Error loading repair plans from {args.plans}: {e}")
            return 1
    else:
        # Generate repair plans
        logger.info("No repair plans provided, generating new plans")
        
        # Get bugs from the bug detector
        from triangulum_lx.agents.bug_detector_agent import BugDetectorAgent
        bug_detector = BugDetectorAgent(agent_id="bug_detector_cli")
        
        if target_path.is_file():
            # Scan a single file
            bugs = bug_detector.detect_bugs_in_file(
                file_path=str(target_path),
                verify_bugs=True
            )
        else:
            # Scan a directory
            result = bug_detector.detect_bugs_in_folder(
                folder_path=str(target_path),
                recursive=True
            )
            bugs = []
            if 'bugs_by_file' in result:
                for file_path, file_bugs in result['bugs_by_file'].items():
                    for bug in file_bugs:
                        bugs.append(bug)
        
        # Create repair plans for each bug
        repair_plans = []
        for bug in bugs:
            # Create a file change for the bug
            file_path = bug.file_path
            if not file_path:
                continue
            
            # Read the file content
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
            except Exception as e:
                logger.error(f"Error reading file {file_path}: {e}")
                continue
            
            # Get the line number
            line_number = bug.line_number
            if not line_number:
                continue
            
            # Create a file change
            lines = content.splitlines()
            start_line = max(1, line_number)
            end_line = min(len(lines), line_number + 1)
            
            # Get the original content
            original_content = "\n".join(lines[start_line-1:end_line])
            
            # Create a placeholder for the new content
            # In a real implementation, this would be generated by an LLM
            new_content = f"# Fixed: {bug.bug_type.value} - {bug.description}\n{original_content}"
            
            file_change = FileChange(
                file_path=file_path,
                start_line=start_line,
                end_line=end_line,
                original_content=original_content,
                new_content=new_content,
                change_type="replace",
                metadata={"bug": bug}
            )
            
            # Create a repair plan
            repair_plan = repair_tool.create_repair_plan(
                name=f"Fix {bug.bug_type.value} in {file_path}",
                description=bug.description,
                changes=[file_change],
                metadata={"bug": bug.to_dict()}
            )
            
            repair_plans.append(repair_plan)
    
    # Apply the repair plans
    applied_plans = []
    failed_plans = []
    
    for plan in repair_plans:
        logger.info(f"Applying repair plan: {plan.name}")
        
        # Apply the repair plan
        result = repair_tool.apply_repair(plan.id, dry_run=args.dry_run)
        
        if result.get('success'):
            applied_plans.append((plan, result))
            logger.info(f"Successfully applied repair plan: {plan.name}")
        else:
            failed_plans.append((plan, result))
            logger.error(f"Failed to apply repair plan: {plan.name}")
            logger.error(f"Error: {result.get('message')}")
    
    # Print the results
    print(f"\n=== Repair Results ===")
    print(f"Applied: {len(applied_plans)}")
    print(f"Failed: {len(failed_plans)}")
    
    if applied_plans:
        print(f"\n=== Applied Repairs ===")
        for plan, result in applied_plans:
            print(f"\n{plan.name}")
            print(f"  ID: {plan.id}")
            print(f"  Affected Files: {', '.join(plan.get_affected_files())}")
            print(f"  Changes: {len(plan.changes)}")
    
    if failed_plans:
        print(f"\n=== Failed Repairs ===")
        for plan, result in failed_plans:
            print(f"\n{plan.name}")
            print(f"  ID: {plan.id}")
            print(f"  Error: {result.get('message')}")
    
    return 0

def verify_repairs(args):
    """
    Verify repairs applied to a codebase.
    
    Args:
        args: Command-line arguments
    """
    target_path = Path(args.path)
    
    if not target_path.exists():
        logger.error(f"Path does not exist: {target_path}")
        return 1
    
    logger.info(f"Verifying repairs for {target_path}")
    
    # Create a repair tool
    repair_tool = RepairTool()
    
    # Get all repair plans
    repair_plans = repair_tool.get_all_repairs()
    
    # Filter for completed repairs
    completed_repairs = [plan for plan in repair_plans if plan.get('status') == 'COMPLETED']
    
    if not completed_repairs:
        logger.warning("No completed repairs found to verify")
        return 0
    
    # Verify each repair
    verified_repairs = []
    failed_verifications = []
    
    for plan in completed_repairs:
        logger.info(f"Verifying repair: {plan.get('name')}")
        
        # Verify the repair
        result = repair_tool.verify_repair(
            plan.get('repair_id'),
            run_tests=args.run_tests,
            check_static_analysis=args.static_analysis
        )
        
        if result.get('success'):
            verified_repairs.append((plan, result))
            logger.info(f"Successfully verified repair: {plan.get('name')}")
        else:
            failed_verifications.append((plan, result))
            logger.error(f"Failed to verify repair: {plan.get('name')}")
            logger.error(f"Error: {result.get('message')}")
    
    # Print the results
    print(f"\n=== Verification Results ===")
    print(f"Verified: {len(verified_repairs)}")
    print(f"Failed: {len(failed_verifications)}")
    
    if verified_repairs:
        print(f"\n=== Verified Repairs ===")
        for plan, result in verified_repairs:
            print(f"\n{plan.get('name')}")
            print(f"  ID: {plan.get('repair_id')}")
            print(f"  Affected Files: {', '.join(plan.get('affected_files', []))}")
    
    if failed_verifications:
        print(f"\n=== Failed Verifications ===")
        for plan, result in failed_verifications:
            print(f"\n{plan.get('name')}")
            print(f"  ID: {plan.get('repair_id')}")
            print(f"  Error: {result.get('message')}")
    
    return 0

def main():
    """Main function to run the repair tool."""
    parser = argparse.ArgumentParser(
        description="Plan and apply repairs to a codebase."
    )
    
    parser.add_argument(
        'path',
        help='Path to the codebase to repair'
    )
    parser.add_argument(
        '--verbose',
        action='store_true',
        help='Enable verbose logging'
    )
    args = parser.parse_args()
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    try:
        args.output = None
        args.plans = None
        args.dry_run = False
        args.run_tests = True
        args.static_analysis = True
        plan_repairs(args)
        apply_repairs(args)
        verify_repairs(args)
        return 0
    except Exception as e:
        logger.error(f"Error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1

if __name__ == "__main__":
    sys.exit(main())
