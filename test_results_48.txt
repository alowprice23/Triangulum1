============================= test session starts ==============================
platform linux -- Python 3.12.11, pytest-8.4.1, pluggy-1.6.0
rootdir: /app
configfile: pytest.ini
plugins: mock-3.14.1, anyio-4.9.0, timeout-2.4.0
collected 426 items

tests/edge_cases/test_folder_healing_edge_cases.py .                     [  0%]
tests/fs/test_consistency.py ..........                                  [  2%]
tests/integration/test_dependency_analysis.py .....                      [  3%]
tests/integration/test_folder_healing.py FF                              [  4%]
tests/integration/test_learning_integration.py ...                       [  4%]
tests/integration/test_system_startup_integration.py FFFs                [  5%]
tests/temp_test.py .                                                     [  6%]
tests/test_agentic_dashboard.py .                                        [  6%]
tests/test_openai.py .                                                   [  6%]
tests/test_startup_sequence.py ....                                      [  7%]
tests/unit/test_agent_message.py ............FFFFF                       [ 11%]
tests/unit/test_auto_verification.py ...                                 [ 12%]
tests/unit/test_base_agent.py FFFFF..F.FF..........                      [ 17%]
tests/unit/test_bug_detector_agent.py .........FF.....FF..               [ 21%]
tests/unit/test_bug_detector_enhancements.py FFFFF                       [ 23%]
tests/unit/test_chain_node.py .................                          [ 26%]
tests/unit/test_code_fixer.py .....                                      [ 28%]
tests/unit/test_engine.py .                                              [ 28%]
tests/unit/test_enhanced_message_bus.py FFFFFFFFFFFF.FFF..........       [ 34%]
tests/unit/test_feedback_collector.py F.F......                          [ 36%]
tests/unit/test_fix_impact_tracker.py ...                                [ 37%]
tests/unit/test_fs_ops.py ............F                                  [ 40%]
tests/unit/test_fs_state.py ...........                                  [ 42%]
tests/unit/test_implementation_agent.py ........                         [ 44%]
tests/unit/test_incremental_analyzer.py ..                               [ 45%]
tests/unit/test_learning_components.py ....                              [ 46%]
tests/unit/test_memory_manager.py ................                       [ 50%]
tests/unit/test_message_schema.py ........................               [ 55%]
tests/unit/test_message_schema_validator.py ................             [ 59%]
tests/unit/test_o3_provider.py ..........                                [ 61%]
tests/unit/test_orchestrator_agent_new.py .                              [ 61%]
tests/unit/test_patch_bundle.py .....                                    [ 63%]
tests/unit/test_patcher_agent.py .........                               [ 65%]
tests/unit/test_priority_analyzer_agent.py FF.                           [ 65%]
tests/unit/test_quantum_entanglement.py .........                        [ 68%]
tests/unit/test_quantum_parallelization.py .                             [ 68%]
tests/unit/test_relationship_analyst_agent.py FFFFFF.FFFFF               [ 71%]
tests/unit/test_relationship_context_provider.py ....                    [ 72%]
tests/unit/test_response_handling.py .F.FF                               [ 73%]
tests/unit/test_rollback_manager.py ....                                 [ 74%]
tests/unit/test_router.py .....                                          [ 75%]
tests/unit/test_state.py .....                                           [ 76%]
tests/unit/test_strategy_agent.py ......F.FF                             [ 78%]
tests/unit/test_system_monitor.py .F.F....                               [ 80%]
tests/unit/test_system_startup.py ...........ssss                        [ 84%]
tests/unit/test_thought_chain.py .......................                 [ 89%]
tests/unit/test_thought_chain_manager.py .............                   [ 92%]
tests/unit/test_timeout_handling.py ..........F                          [ 95%]
tests/unit/test_transition.py ..                                         [ 95%]
tests/unit/test_verification_agent.py ........                           [ 97%]
triangulum_lx/tests/smoke/test_simple_bug.py F                           [ 97%]
triangulum_lx/tests/unit/test_state.py ....                              [ 98%]
triangulum_lx/tests/unit/test_transition.py .....                        [100%]

=================================== FAILURES ===================================
________________ TestFolderHealing.test_folder_healing_dry_run _________________

self = <integration.test_folder_healing.TestFolderHealing testMethod=test_folder_healing_dry_run>

    def test_folder_healing_dry_run(self):
        """Test the entire folder-level healing workflow in dry run mode."""
        # Create a task request message
        message = AgentMessage(
            message_type=MessageType.TASK_REQUEST,
            content={
                "action": "orchestrate_folder_healing",
                "folder_path": self.test_dir,
                "options": {
                    "dry_run": True,
                    "max_files": 10,
                    "analysis_depth": 2
                }
            },
            sender="test_handler",
            receiver="orchestrator"
        )

        # Process the message
        self.orchestrator.handle_message(message)

        # Wait for the result (with timeout)
        start_time = time.time()
        timeout = 30  # 30 seconds timeout for integration test

        while time.time() - start_time < timeout:
            if "orchestrator" in self.results:
                result = self.results["orchestrator"]

                if result.get("status") == "success":
                    break

            # Sleep a bit to avoid busy waiting
            time.sleep(0.1)

        # Check that we got a result
>       self.assertIn("orchestrator", self.results)
E       AssertionError: 'orchestrator' not found in {}

tests/integration/test_folder_healing.py:228: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  triangulum_lx.verification.metrics:metrics.py:52 Metrics path .triangulum/verification/metrics exists but is not a directory. Attempting to create.
_________ TestFolderHealing.test_orchestrator_real_healing_simulation __________

self = <integration.test_folder_healing.TestFolderHealing testMethod=test_orchestrator_real_healing_simulation>

    def test_orchestrator_real_healing_simulation(self):
        """
        Test that the orchestrator correctly simulates a real healing process.

        Instead of actually modifying files, this test mocks the key methods
        to simulate the healing process without modifying real files.
        """
        # Create a copy of our test directory
        sim_dir = tempfile.mkdtemp()
        try:
            # Copy test project to simulation directory
            shutil.copytree(self.test_dir, sim_dir, dirs_exist_ok=True)

            # Create a simulated message
            message = AgentMessage(
                message_type=MessageType.TASK_REQUEST,
                content={
                    "action": "orchestrate_folder_healing",
                    "folder_path": sim_dir,
                    "options": {"dry_run": False}
                },
                sender="test_handler",
                receiver="orchestrator"
            )

            # Replace the orchestrator's _heal_single_file_in_folder method
            # with a version that pretends to fix bugs
>           original_heal = self.orchestrator._heal_single_file_in_folder
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'OrchestratorAgent' object has no attribute '_heal_single_file_in_folder'

tests/integration/test_folder_healing.py:312: AttributeError
------------------------------ Captured log call -------------------------------
WARNING  triangulum_lx.verification.metrics:metrics.py:52 Metrics path .triangulum/verification/metrics exists but is not a directory. Attempting to create.
_____________ TestSystemStartupIntegration.test_graceful_shutdown ______________

self = <integration.test_system_startup_integration.TestSystemStartupIntegration testMethod=test_graceful_shutdown>
mock_init_message_bus = <MagicMock name='_init_message_bus' id='140532405232432'>
mock_init_provider_factory = <MagicMock name='_init_provider_factory' id='140532405238864'>
mock_init_agent_factory = <MagicMock name='_init_agent_factory' id='140532405422944'>
mock_init_meta_agent = <MagicMock name='_init_meta_agent' id='140532405232576'>
mock_init_bug_detector = <MagicMock name='_init_bug_detector' id='140532405428416'>
mock_shutdown_message_bus = <MagicMock name='_shutdown_message_bus' id='140532408746688'>
mock_shutdown_provider_factory = <MagicMock name='_shutdown_provider_factory' id='140532405436000'>
mock_shutdown_agent_factory = <MagicMock name='_shutdown_agent_factory' id='140532405489056'>

    @patch('triangulum_lx.core.engine.TriangulumEngine._shutdown_agent_factory')
    @patch('triangulum_lx.core.engine.TriangulumEngine._shutdown_provider_factory')
    @patch('triangulum_lx.core.engine.TriangulumEngine._shutdown_message_bus')
    @patch('triangulum_lx.core.engine.TriangulumEngine._init_bug_detector')
    @patch('triangulum_lx.core.engine.TriangulumEngine._init_meta_agent')
    @patch('triangulum_lx.core.engine.TriangulumEngine._init_agent_factory')
    @patch('triangulum_lx.core.engine.TriangulumEngine._init_provider_factory')
    @patch('triangulum_lx.core.engine.TriangulumEngine._init_message_bus')
    def test_graceful_shutdown(self, mock_init_message_bus, mock_init_provider_factory,
                             mock_init_agent_factory, mock_init_meta_agent, mock_init_bug_detector,
                             mock_shutdown_message_bus, mock_shutdown_provider_factory,
                             mock_shutdown_agent_factory):
        """Test graceful shutdown of system components."""
        # Configure mocks to return component instances
        mock_init_message_bus.return_value = Mock(name="message_bus")
        mock_init_provider_factory.return_value = Mock(name="provider_factory")
        mock_init_agent_factory.return_value = Mock(name="agent_factory")
        mock_init_meta_agent.return_value = Mock(name="meta_agent")
        mock_init_bug_detector.return_value = Mock(name="bug_detector")

        # Create an engine with the test configuration
        engine = TriangulumEngine(self.test_config)

        # Initialize engine
        result = engine.initialize()

        # Verify initialization was successful
>       self.assertTrue(result)
E       AssertionError: False is not true

tests/integration/test_system_startup_integration.py:97: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    triangulum.engine:engine.py:210 Configuration validation failed: Missing 'llm' section in main config.
ERROR    triangulum.engine:engine.py:159 Configuration validation failed
_______ TestSystemStartupIntegration.test_startup_dashboard_integration ________

self = <integration.test_system_startup_integration.TestSystemStartupIntegration testMethod=test_startup_dashboard_integration>
mock_init_message_bus = <MagicMock name='_init_message_bus' id='140532405495488'>
mock_init_provider_factory = <MagicMock name='_init_provider_factory' id='140532405499904'>
mock_init_agent_factory = <MagicMock name='_init_agent_factory' id='140532405535952'>
mock_init_meta_agent = <MagicMock name='_init_meta_agent' id='140532405540080'>
mock_init_bug_detector = <MagicMock name='_init_bug_detector' id='140532405544016'>

    @patch('triangulum_lx.core.engine.TriangulumEngine._init_bug_detector')
    @patch('triangulum_lx.core.engine.TriangulumEngine._init_meta_agent')
    @patch('triangulum_lx.core.engine.TriangulumEngine._init_agent_factory')
    @patch('triangulum_lx.core.engine.TriangulumEngine._init_provider_factory')
    @patch('triangulum_lx.core.engine.TriangulumEngine._init_message_bus')
    def test_startup_dashboard_integration(self, mock_init_message_bus, mock_init_provider_factory,
                                        mock_init_agent_factory, mock_init_meta_agent, mock_init_bug_detector):
        """Test integration between engine initialization and dashboard monitoring."""
        # Configure mocks to return component instances
        mock_init_message_bus.return_value = Mock(name="message_bus")
        mock_init_provider_factory.return_value = Mock(name="provider_factory")
        mock_init_agent_factory.return_value = Mock(name="agent_factory")
        mock_init_meta_agent.return_value = Mock(name="meta_agent")
        mock_init_bug_detector.return_value = Mock(name="bug_detector")

        # Create a dashboard
        dashboard = StartupDashboard()

        # Create an engine with the test configuration
        engine = TriangulumEngine(self.test_config)

        # Start monitoring
        dashboard.start_monitoring(engine=engine, update_interval=0.1)

        # Initialize engine
        result = engine.initialize(parallel=False)

        # Verify initialization was successful
>       self.assertTrue(result)
E       AssertionError: False is not true

tests/integration/test_system_startup_integration.py:187: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    triangulum.engine:engine.py:210 Configuration validation failed: Missing 'llm' section in main config.
ERROR    triangulum.engine:engine.py:159 Configuration validation failed
__________ TestSystemStartupIntegration.test_system_health_monitoring __________

self = <integration.test_system_startup_integration.TestSystemStartupIntegration testMethod=test_system_health_monitoring>
mock_init_message_bus = <MagicMock name='_init_message_bus' id='140532405550208'>
mock_init_provider_factory = <MagicMock name='_init_provider_factory' id='140532405701472'>
mock_init_agent_factory = <MagicMock name='_init_agent_factory' id='140532405705360'>
mock_init_meta_agent = <MagicMock name='_init_meta_agent' id='140532405709104'>
mock_init_bug_detector = <MagicMock name='_init_bug_detector' id='140532405712944'>
mock_check_health = <MagicMock name='_check_system_health' id='140532405716848'>

    @patch('triangulum_lx.core.engine.TriangulumEngine._check_system_health')
    @patch('triangulum_lx.core.engine.TriangulumEngine._init_bug_detector')
    @patch('triangulum_lx.core.engine.TriangulumEngine._init_meta_agent')
    @patch('triangulum_lx.core.engine.TriangulumEngine._init_agent_factory')
    @patch('triangulum_lx.core.engine.TriangulumEngine._init_provider_factory')
    @patch('triangulum_lx.core.engine.TriangulumEngine._init_message_bus')
    def test_system_health_monitoring(self, mock_init_message_bus, mock_init_provider_factory,
                                   mock_init_agent_factory, mock_init_meta_agent, mock_init_bug_detector,
                                   mock_check_health):
        """Test system health monitoring."""
        # Configure mocks to return component instances
        mock_init_message_bus.return_value = Mock(name="message_bus")
        mock_init_provider_factory.return_value = Mock(name="provider_factory")
        mock_init_agent_factory.return_value = Mock(name="agent_factory")
        mock_init_meta_agent.return_value = Mock(name="meta_agent")
        mock_init_bug_detector.return_value = Mock(name="bug_detector")

        # Mock the health check to return a valid status
        mock_check_health.return_value = {
            "overall_health": True,
            "components": {
                "message_bus": {"status": "ready"},
                "provider_factory": {"status": "ready"},
                "agent_factory": {"status": "ready"}
            }
        }

        # Create an engine with the test configuration
        engine = TriangulumEngine(self.test_config)

        # Initialize engine
        result = engine.initialize()

        # Verify initialization was successful
>       self.assertTrue(result)
E       AssertionError: False is not true

tests/integration/test_system_startup_integration.py:145: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    triangulum.engine:engine.py:210 Configuration validation failed: Missing 'llm' section in main config.
ERROR    triangulum.engine:engine.py:159 Configuration validation failed
____________________ TestMessageBus.test_broadcast_message _____________________

self = <MagicMock id='140532352822896'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'mock' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_agent_message.TestMessageBus testMethod=test_broadcast_message>

    def test_broadcast_message(self):
        """Test broadcasting a message to all interested agents."""
        message = AgentMessage(
            message_type=MessageType.TASK_REQUEST,
            content={"task": "Analyze code"},
            sender="agent_c"
        )

        self.message_bus.publish(message)

        # agent_a and agent_b should receive the message (they're subscribed to TASK_REQUEST)
>       self.agent_a_callback.assert_called_once()
E       AssertionError: Expected 'mock' to have been called once. Called 0 times.

tests/unit/test_agent_message.py:455: AssertionError
_________________ TestMessageBus.test_conversation_management __________________

self = <unit.test_agent_message.TestMessageBus testMethod=test_conversation_management>

    def test_conversation_management(self):
        """Test conversation management functionality."""
        # Create and publish messages in a conversation
        message1 = AgentMessage(
            message_type=MessageType.TASK_REQUEST,
            content={"task": "Task 1"},
            sender="agent_a",
            receiver="agent_b",
            conversation_id="test_convo"
        )

        message2 = AgentMessage(
            message_type=MessageType.TASK_RESULT,
            content={"result": "Result 1"},
            sender="agent_b",
            receiver="agent_a",
            conversation_id="test_convo",
            parent_id=message1.message_id
        )

        self.message_bus.publish(message1)
        self.message_bus.publish(message2)

        # Get the conversation
        conversation = self.message_bus.get_conversation("test_convo")
>       self.assertIsNotNone(conversation)
E       AssertionError: unexpectedly None

tests/unit/test_agent_message.py:546: AssertionError
_________________ TestMessageBus.test_direct_message_delivery __________________

self = <MagicMock id='140532353319712'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'mock' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_agent_message.TestMessageBus testMethod=test_direct_message_delivery>

    def test_direct_message_delivery(self):
        """Test delivering a message to a specific agent."""
        message = AgentMessage(
            message_type=MessageType.TASK_REQUEST,
            content={"task": "Analyze code"},
            sender="agent_a",
            receiver="agent_b",
        )

        self.message_bus.publish(message)

        # agent_b should receive the message
>       self.agent_b_callback.assert_called_once()
E       AssertionError: Expected 'mock' to have been called once. Called 0 times.

tests/unit/test_agent_message.py:430: AssertionError
__________________ TestMessageBus.test_message_type_filtering __________________

self = <unit.test_agent_message.TestMessageBus testMethod=test_message_type_filtering>

    def test_message_type_filtering(self):
        """Test that messages are filtered by type."""
        # Send a message type that agent_a is not subscribed to
        message = AgentMessage(
            message_type=MessageType.TASK_RESULT,
            content={"result": "Analysis complete"},
            sender="agent_c",
            receiver="agent_a"
        )

        self.message_bus.publish(message)

        # agent_a should not receive the message (not subscribed to TASK_RESULT)
        self.agent_a_callback.assert_not_called()

        # But it should still be stored in conversation memory
        conversation = self.message_bus.get_conversation(message.conversation_id)
>       self.assertIsNotNone(conversation)
E       AssertionError: unexpectedly None

tests/unit/test_agent_message.py:478: AssertionError
_______________________ TestMessageBus.test_unsubscribe ________________________

self = <MagicMock id='140532353248016'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'mock' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_agent_message.TestMessageBus testMethod=test_unsubscribe>

    def test_unsubscribe(self):
        """Test unsubscribing from the message bus."""
        # Unsubscribe agent_a from all message types
        self.message_bus.unsubscribe(agent_id="agent_a")

        # Unsubscribe agent_b from TASK_RESULT only
        self.message_bus.unsubscribe(
            agent_id="agent_b",
            message_types=[MessageType.TASK_RESULT]
        )

        # Send a TASK_REQUEST message
        message1 = AgentMessage(
            message_type=MessageType.TASK_REQUEST,
            content={"task": "Analyze code"},
            sender="agent_c"
        )

        self.message_bus.publish(message1)

        # agent_a should not receive it (unsubscribed from all)
        self.agent_a_callback.assert_not_called()

        # agent_b should still receive it (still subscribed to TASK_REQUEST)
>       self.agent_b_callback.assert_called_once()
E       AssertionError: Expected 'mock' to have been called once. Called 0 times.

tests/unit/test_agent_message.py:505: AssertionError
_____________________ TestBaseAgent.test_broadcast_status ______________________

self = <AsyncMock name='mock.publish' id='140532342183008'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'publish' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_base_agent.TestBaseAgent testMethod=test_broadcast_status>

    def test_broadcast_status(self):
        """Test broadcasting status messages."""
        message_id = self.agent.broadcast_status(
            status="test status",
            metadata={"meta": "data"}
        )

        self.assertIsNotNone(message_id)
>       self.message_bus_mock.publish.assert_called_once()
E       AssertionError: Expected 'publish' to have been called once. Called 0 times.

tests/unit/test_base_agent.py:233: AssertionError
___________________ TestBaseAgent.test_handle_message_error ____________________

self = <MagicMock name='logger.warning' id='140532342421984'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'warning' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_base_agent.TestBaseAgent testMethod=test_handle_message_error>

    def test_handle_message_error(self):
        """Test handling error messages."""
        message = AgentMessage(
            message_type=MessageType.ERROR,
            content={"error": "test error"},
            sender="sender_agent"
        )

        # Need to mock the logger to verify it's called
        with patch("triangulum_lx.agents.base_agent.logger") as mock_logger:
            self.agent.handle_message(message)
>           mock_logger.warning.assert_called_once()
E           AssertionError: Expected 'warning' to have been called once. Called 0 times.

tests/unit/test_base_agent.py:147: AssertionError
___________________ TestBaseAgent.test_handle_message_query ____________________

self = <unit.test_base_agent.TestBaseAgent testMethod=test_handle_message_query>

    def test_handle_message_query(self):
        """Test handling query messages."""
        message = AgentMessage(
            message_type=MessageType.QUERY,
            content={"query": "test query"},
            sender="sender_agent"
        )

        self.agent.handle_message(message)

>       self.assertEqual(len(self.agent.queries_handled), 1)
E       AssertionError: 0 != 1

tests/unit/test_base_agent.py:125: AssertionError
___________________ TestBaseAgent.test_handle_message_status ___________________

self = <unit.test_base_agent.TestBaseAgent testMethod=test_handle_message_status>

    def test_handle_message_status(self):
        """Test handling status messages."""
        message = AgentMessage(
            message_type=MessageType.STATUS,
            content={"status": "test status", "agent_type": "other_agent"},
            sender="sender_agent"
        )

        # Need to mock the logger to verify it's called
        with patch("triangulum_lx.agents.base_agent.logger") as mock_logger:
            self.agent.handle_message(message)
            # Check that debug was called at least once with the status message
>           self.assertTrue(mock_logger.debug.called)
E           AssertionError: False is not true

tests/unit/test_base_agent.py:162: AssertionError
________________ TestBaseAgent.test_handle_message_task_request ________________

self = <unit.test_base_agent.TestBaseAgent testMethod=test_handle_message_task_request>

    def test_handle_message_task_request(self):
        """Test handling task request messages."""
        message = AgentMessage(
            message_type=MessageType.TASK_REQUEST,
            content={"task": "test task"},
            sender="sender_agent"
        )

        self.agent.handle_message(message)

>       self.assertEqual(len(self.agent.task_requests_handled), 1)
E       AssertionError: 0 != 1

tests/unit/test_base_agent.py:104: AssertionError
______________________ TestBaseAgent.test_no_message_bus _______________________

self = <unit.test_base_agent.TestBaseAgent testMethod=test_no_message_bus>

    def test_no_message_bus(self):
        """Test agent behavior without a message bus."""
        agent = TestAgent(agent_id="no_bus_agent")

        # These operations should not raise exceptions even without a message bus
        agent.initialize()
        agent.shutdown()

        # Sending messages should return None but not raise exceptions
>       self.assertIsNone(agent.send_message(
            message_type=MessageType.TASK_REQUEST,
            content={"task": "test"}
        ))
E       AssertionError: <coroutine object BaseAgent.send_message at 0x7fd03d96d220> is not None

tests/unit/test_base_agent.py:253: AssertionError
_______________________ TestBaseAgent.test_send_message ________________________

self = <AsyncMock name='mock.publish' id='140532405711744'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'publish' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_base_agent.TestBaseAgent testMethod=test_send_message>

    def test_send_message(self):
        """Test sending messages."""
        message_id = self.agent.send_message(
            message_type=MessageType.TASK_REQUEST,
            content={"task": "test task"},
            receiver="receiver_agent",
            confidence=0.8,
            metadata={"meta": "data"}
        )

        self.assertIsNotNone(message_id)
>       self.message_bus_mock.publish.assert_called_once()
E       AssertionError: Expected 'publish' to have been called once. Called 0 times.

tests/unit/test_base_agent.py:182: AssertionError
_______________________ TestBaseAgent.test_send_response _______________________

self = <AsyncMock name='mock.publish' id='140532342020224'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'publish' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_base_agent.TestBaseAgent testMethod=test_send_response>

    def test_send_response(self):
        """Test sending response messages."""
        original_message = AgentMessage(
            message_type=MessageType.TASK_REQUEST,
            content={"task": "test task"},
            sender="sender_agent",
            message_id="original_id",
            conversation_id="convo_id"
        )

        message_id = self.agent.send_response(
            original_message=original_message,
            message_type=MessageType.TASK_RESULT,
            content={"result": "test result"},
            confidence=0.9,
            metadata={"meta": "data"}
        )

        self.assertIsNotNone(message_id)
>       self.message_bus_mock.publish.assert_called_once()
E       AssertionError: Expected 'publish' to have been called once. Called 0 times.

tests/unit/test_base_agent.py:212: AssertionError
___________________ TestBugDetectorAgent.test_error_handling ___________________

self = <MagicMock name='mock.publish' id='140532405116448'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'publish' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_bug_detector_agent.TestBugDetectorAgent testMethod=test_error_handling>

    def test_error_handling(self):
        """Test error handling in message processing."""
        # Create a mock message with an invalid query type
        message = AgentMessage(
            message_type=MessageType.QUERY,
            content={
                "query_type": "invalid_query"
            },
            sender="test_sender"
        )

        # Handle the message
        self.agent._handle_query(message)

        # Verify that send_response was called with an error message
>       self.agent.message_bus.publish.assert_called_once()
E       AssertionError: Expected 'publish' to have been called once. Called 0 times.

tests/unit/test_bug_detector_agent.py:359: AssertionError
_________ TestBugDetectorAgent.test_error_response_in_message_handling _________

self = <MagicMock name='mock.publish' id='140532341633968'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'publish' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_bug_detector_agent.TestBugDetectorAgent testMethod=test_error_response_in_message_handling>

    def test_error_response_in_message_handling(self):
        """Test that errors are properly reported in message responses."""
        # Create a task request message with missing file_path
        message = AgentMessage(
            message_type=MessageType.TASK_REQUEST,
            content={
                "action": "detect_bugs_in_file",
                # Missing file_path parameter
            },
            sender="test_sender"
        )

        # Handle the message
        self.agent._handle_task_request(message)

        # Verify the error response
>       self.agent.message_bus.publish.assert_called_once()
E       AssertionError: Expected 'publish' to have been called once. Called 0 times.

tests/unit/test_bug_detector_agent.py:557: AssertionError
___________ TestBugDetectorAgent.test_handle_query_get_bug_patterns ____________

self = <MagicMock name='mock.publish' id='140532341206688'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'publish' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_bug_detector_agent.TestBugDetectorAgent testMethod=test_handle_query_get_bug_patterns>

    def test_handle_query_get_bug_patterns(self):
        """Test handling a query for bug patterns."""
        # Create a mock message
        message = AgentMessage(
            message_type=MessageType.QUERY,
            content={
                "query_type": "get_bug_patterns",
                "language": "python"
            },
            sender="test_sender"
        )

        # Handle the message
        self.agent._handle_query(message)

        # Verify that send_response was called with the correct arguments
>       self.agent.message_bus.publish.assert_called_once()
E       AssertionError: Expected 'publish' to have been called once. Called 0 times.

tests/unit/test_bug_detector_agent.py:338: AssertionError
__________ TestBugDetectorAgent.test_handle_task_request_detect_bugs ___________

self = <MagicMock name='mock.publish' id='140532342413632'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'publish' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_bug_detector_agent.TestBugDetectorAgent testMethod=test_handle_task_request_detect_bugs>

        def test_handle_task_request_detect_bugs(self):
            """Test handling a task request to detect bugs."""
            # Create a Python file with a bug
            file_content = """
    def process_data(data):
        # This will cause a null reference error if data is None
        return data.get('value')
    """
            file_path = self.create_test_file("null_reference.py", file_content)

            # Create a mock message
            message = AgentMessage(
                message_type=MessageType.TASK_REQUEST,
                content={
                    "action": "detect_bugs_in_file",
                    "file_path": file_path
                },
                sender="test_sender"
            )

            # Handle the message
            self.agent._handle_task_request(message)

            # Verify that send_response was called with the correct arguments
>           self.agent.message_bus.publish.assert_called_once()
E           AssertionError: Expected 'publish' to have been called once. Called 0 times.

tests/unit/test_bug_detector_agent.py:316: AssertionError
_____________ TestBugDetectorEnhancements.test_bug_classification ______________

self = <unit.test_bug_detector_enhancements.TestBugDetectorEnhancements testMethod=test_bug_classification>

    def setUp(self):
        """Set up test fixtures."""
        # Create a mock relationship analyst
        self.mock_relationship_analyst = MagicMock(spec=RelationshipAnalystAgent)
        self.mock_relationship_analyst.get_file_dependencies.return_value = {"dependent1.py", "dependent2.py"}
        self.mock_relationship_analyst.get_file_dependents.return_value = {"parent1.py", "parent2.py", "parent3.py"}
        self.mock_relationship_analyst.get_most_central_files.return_value = [("central1.py", 0.9), ("central2.py", 0.8)]

        # Create the bug detector with enhancements
>       self.bug_detector = BugDetectorAgent(
            agent_id="test_bug_detector",
            enable_context_aware_detection=True,
            enable_multi_pass_verification=True,
            false_positive_threshold=0.8,
            use_ast_parsing=True
        )

tests/unit/test_bug_detector_enhancements.py:39:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <triangulum_lx.agents.bug_detector_agent.BugDetectorAgent object at 0x7fd03c546870>
agent_id = 'test_bug_detector', message_bus = None, config = None
kwargs = {'enable_context_aware_detection': True, 'enable_multi_pass_verification': True, 'false_positive_threshold': 0.8, 'use_ast_parsing': True}

    def __init__(
        self,
        agent_id: Optional[str] = None,
        # agent_type: str = "bug_detector", # Use AGENT_TYPE
        message_bus: Optional[EnhancedMessageBus] = None,
        # subscribed_message_types: Optional[List[MessageType]] = None, # Define in super
        config: Optional[Dict[str, Any]] = None,
        **kwargs # Added for BaseAgent params like engine_monitor
    ):
        """
        Initialize the Bug Detector Agent.

        Args:
            agent_id: Unique identifier for the agent (generated if not provided)
            message_bus: Message bus for agent communication
            config: Agent configuration dictionary. Expected to contain keys like:
                    'max_bug_patterns', 'max_file_size',
                    'relationship_analyst_agent_id' (optional),
                    'enable_context_aware_detection', 'enable_multi_pass_verification',
                    'false_positive_threshold', 'use_ast_parsing'.
        """
>       super().__init__(
            agent_id=agent_id,
            agent_type=self.AGENT_TYPE,
            message_bus=message_bus,
            subscribed_message_types=[MessageType.TASK_REQUEST, MessageType.QUERY], # Define directly
            config=config,
            **kwargs # Pass kwargs
        )
E       TypeError: BaseAgent.__init__() got an unexpected keyword argument 'enable_context_aware_detection'

triangulum_lx/agents/bug_detector_agent.py:235: TypeError
___________ TestBugDetectorEnhancements.test_context_aware_detection ___________

self = <unit.test_bug_detector_enhancements.TestBugDetectorEnhancements testMethod=test_context_aware_detection>

    def setUp(self):
        """Set up test fixtures."""
        # Create a mock relationship analyst
        self.mock_relationship_analyst = MagicMock(spec=RelationshipAnalystAgent)
        self.mock_relationship_analyst.get_file_dependencies.return_value = {"dependent1.py", "dependent2.py"}
        self.mock_relationship_analyst.get_file_dependents.return_value = {"parent1.py", "parent2.py", "parent3.py"}
        self.mock_relationship_analyst.get_most_central_files.return_value = [("central1.py", 0.9), ("central2.py", 0.8)]

        # Create the bug detector with enhancements
>       self.bug_detector = BugDetectorAgent(
            agent_id="test_bug_detector",
            enable_context_aware_detection=True,
            enable_multi_pass_verification=True,
            false_positive_threshold=0.8,
            use_ast_parsing=True
        )

tests/unit/test_bug_detector_enhancements.py:39:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <triangulum_lx.agents.bug_detector_agent.BugDetectorAgent object at 0x7fd03c5f3f50>
agent_id = 'test_bug_detector', message_bus = None, config = None
kwargs = {'enable_context_aware_detection': True, 'enable_multi_pass_verification': True, 'false_positive_threshold': 0.8, 'use_ast_parsing': True}

    def __init__(
        self,
        agent_id: Optional[str] = None,
        # agent_type: str = "bug_detector", # Use AGENT_TYPE
        message_bus: Optional[EnhancedMessageBus] = None,
        # subscribed_message_types: Optional[List[MessageType]] = None, # Define in super
        config: Optional[Dict[str, Any]] = None,
        **kwargs # Added for BaseAgent params like engine_monitor
    ):
        """
        Initialize the Bug Detector Agent.

        Args:
            agent_id: Unique identifier for the agent (generated if not provided)
            message_bus: Message bus for agent communication
            config: Agent configuration dictionary. Expected to contain keys like:
                    'max_bug_patterns', 'max_file_size',
                    'relationship_analyst_agent_id' (optional),
                    'enable_context_aware_detection', 'enable_multi_pass_verification',
                    'false_positive_threshold', 'use_ast_parsing'.
        """
>       super().__init__(
            agent_id=agent_id,
            agent_type=self.AGENT_TYPE,
            message_bus=message_bus,
            subscribed_message_types=[MessageType.TASK_REQUEST, MessageType.QUERY], # Define directly
            config=config,
            **kwargs # Pass kwargs
        )
E       TypeError: BaseAgent.__init__() got an unexpected keyword argument 'enable_context_aware_detection'

triangulum_lx/agents/bug_detector_agent.py:235: TypeError
__________ TestBugDetectorEnhancements.test_false_positive_reduction ___________

self = <unit.test_bug_detector_enhancements.TestBugDetectorEnhancements testMethod=test_false_positive_reduction>

    def setUp(self):
        """Set up test fixtures."""
        # Create a mock relationship analyst
        self.mock_relationship_analyst = MagicMock(spec=RelationshipAnalystAgent)
        self.mock_relationship_analyst.get_file_dependencies.return_value = {"dependent1.py", "dependent2.py"}
        self.mock_relationship_analyst.get_file_dependents.return_value = {"parent1.py", "parent2.py", "parent3.py"}
        self.mock_relationship_analyst.get_most_central_files.return_value = [("central1.py", 0.9), ("central2.py", 0.8)]

        # Create the bug detector with enhancements
>       self.bug_detector = BugDetectorAgent(
            agent_id="test_bug_detector",
            enable_context_aware_detection=True,
            enable_multi_pass_verification=True,
            false_positive_threshold=0.8,
            use_ast_parsing=True
        )

tests/unit/test_bug_detector_enhancements.py:39:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <triangulum_lx.agents.bug_detector_agent.BugDetectorAgent object at 0x7fd03c40d610>
agent_id = 'test_bug_detector', message_bus = None, config = None
kwargs = {'enable_context_aware_detection': True, 'enable_multi_pass_verification': True, 'false_positive_threshold': 0.8, 'use_ast_parsing': True}

    def __init__(
        self,
        agent_id: Optional[str] = None,
        # agent_type: str = "bug_detector", # Use AGENT_TYPE
        message_bus: Optional[EnhancedMessageBus] = None,
        # subscribed_message_types: Optional[List[MessageType]] = None, # Define in super
        config: Optional[Dict[str, Any]] = None,
        **kwargs # Added for BaseAgent params like engine_monitor
    ):
        """
        Initialize the Bug Detector Agent.

        Args:
            agent_id: Unique identifier for the agent (generated if not provided)
            message_bus: Message bus for agent communication
            config: Agent configuration dictionary. Expected to contain keys like:
                    'max_bug_patterns', 'max_file_size',
                    'relationship_analyst_agent_id' (optional),
                    'enable_context_aware_detection', 'enable_multi_pass_verification',
                    'false_positive_threshold', 'use_ast_parsing'.
        """
>       super().__init__(
            agent_id=agent_id,
            agent_type=self.AGENT_TYPE,
            message_bus=message_bus,
            subscribed_message_types=[MessageType.TASK_REQUEST, MessageType.QUERY], # Define directly
            config=config,
            **kwargs # Pass kwargs
        )
E       TypeError: BaseAgent.__init__() got an unexpected keyword argument 'enable_context_aware_detection'

triangulum_lx/agents/bug_detector_agent.py:235: TypeError
_________ TestBugDetectorEnhancements.test_folder_analysis_performance _________

self = <unit.test_bug_detector_enhancements.TestBugDetectorEnhancements testMethod=test_folder_analysis_performance>

    def setUp(self):
        """Set up test fixtures."""
        # Create a mock relationship analyst
        self.mock_relationship_analyst = MagicMock(spec=RelationshipAnalystAgent)
        self.mock_relationship_analyst.get_file_dependencies.return_value = {"dependent1.py", "dependent2.py"}
        self.mock_relationship_analyst.get_file_dependents.return_value = {"parent1.py", "parent2.py", "parent3.py"}
        self.mock_relationship_analyst.get_most_central_files.return_value = [("central1.py", 0.9), ("central2.py", 0.8)]

        # Create the bug detector with enhancements
>       self.bug_detector = BugDetectorAgent(
            agent_id="test_bug_detector",
            enable_context_aware_detection=True,
            enable_multi_pass_verification=True,
            false_positive_threshold=0.8,
            use_ast_parsing=True
        )

tests/unit/test_bug_detector_enhancements.py:39:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <triangulum_lx.agents.bug_detector_agent.BugDetectorAgent object at 0x7fd03c5068d0>
agent_id = 'test_bug_detector', message_bus = None, config = None
kwargs = {'enable_context_aware_detection': True, 'enable_multi_pass_verification': True, 'false_positive_threshold': 0.8, 'use_ast_parsing': True}

    def __init__(
        self,
        agent_id: Optional[str] = None,
        # agent_type: str = "bug_detector", # Use AGENT_TYPE
        message_bus: Optional[EnhancedMessageBus] = None,
        # subscribed_message_types: Optional[List[MessageType]] = None, # Define in super
        config: Optional[Dict[str, Any]] = None,
        **kwargs # Added for BaseAgent params like engine_monitor
    ):
        """
        Initialize the Bug Detector Agent.

        Args:
            agent_id: Unique identifier for the agent (generated if not provided)
            message_bus: Message bus for agent communication
            config: Agent configuration dictionary. Expected to contain keys like:
                    'max_bug_patterns', 'max_file_size',
                    'relationship_analyst_agent_id' (optional),
                    'enable_context_aware_detection', 'enable_multi_pass_verification',
                    'false_positive_threshold', 'use_ast_parsing'.
        """
>       super().__init__(
            agent_id=agent_id,
            agent_type=self.AGENT_TYPE,
            message_bus=message_bus,
            subscribed_message_types=[MessageType.TASK_REQUEST, MessageType.QUERY], # Define directly
            config=config,
            **kwargs # Pass kwargs
        )
E       TypeError: BaseAgent.__init__() got an unexpected keyword argument 'enable_context_aware_detection'

triangulum_lx/agents/bug_detector_agent.py:235: TypeError
__________ TestBugDetectorEnhancements.test_relationship_integration ___________

self = <unit.test_bug_detector_enhancements.TestBugDetectorEnhancements testMethod=test_relationship_integration>

    def setUp(self):
        """Set up test fixtures."""
        # Create a mock relationship analyst
        self.mock_relationship_analyst = MagicMock(spec=RelationshipAnalystAgent)
        self.mock_relationship_analyst.get_file_dependencies.return_value = {"dependent1.py", "dependent2.py"}
        self.mock_relationship_analyst.get_file_dependents.return_value = {"parent1.py", "parent2.py", "parent3.py"}
        self.mock_relationship_analyst.get_most_central_files.return_value = [("central1.py", 0.9), ("central2.py", 0.8)]

        # Create the bug detector with enhancements
>       self.bug_detector = BugDetectorAgent(
            agent_id="test_bug_detector",
            enable_context_aware_detection=True,
            enable_multi_pass_verification=True,
            false_positive_threshold=0.8,
            use_ast_parsing=True
        )

tests/unit/test_bug_detector_enhancements.py:39:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <triangulum_lx.agents.bug_detector_agent.BugDetectorAgent object at 0x7fd03c40fe60>
agent_id = 'test_bug_detector', message_bus = None, config = None
kwargs = {'enable_context_aware_detection': True, 'enable_multi_pass_verification': True, 'false_positive_threshold': 0.8, 'use_ast_parsing': True}

    def __init__(
        self,
        agent_id: Optional[str] = None,
        # agent_type: str = "bug_detector", # Use AGENT_TYPE
        message_bus: Optional[EnhancedMessageBus] = None,
        # subscribed_message_types: Optional[List[MessageType]] = None, # Define in super
        config: Optional[Dict[str, Any]] = None,
        **kwargs # Added for BaseAgent params like engine_monitor
    ):
        """
        Initialize the Bug Detector Agent.

        Args:
            agent_id: Unique identifier for the agent (generated if not provided)
            message_bus: Message bus for agent communication
            config: Agent configuration dictionary. Expected to contain keys like:
                    'max_bug_patterns', 'max_file_size',
                    'relationship_analyst_agent_id' (optional),
                    'enable_context_aware_detection', 'enable_multi_pass_verification',
                    'false_positive_threshold', 'use_ast_parsing'.
        """
>       super().__init__(
            agent_id=agent_id,
            agent_type=self.AGENT_TYPE,
            message_bus=message_bus,
            subscribed_message_types=[MessageType.TASK_REQUEST, MessageType.QUERY], # Define directly
            config=config,
            **kwargs # Pass kwargs
        )
E       TypeError: BaseAgent.__init__() got an unexpected keyword argument 'enable_context_aware_detection'

triangulum_lx/agents/bug_detector_agent.py:235: TypeError
_________________ TestEnhancedMessageBus.test_circuit_breaker __________________

self = <unit.test_enhanced_message_bus.TestEnhancedMessageBus testMethod=test_circuit_breaker>

    def test_circuit_breaker(self):
        """Test the circuit breaker pattern for failure isolation."""
        # Create a callback that raises an exception
        def failing_callback(message):
            raise RuntimeError("Simulated failure")

        # Subscribe to messages with the failing callback
        self.message_bus.subscribe(
            agent_id="failing_agent",
            callback=failing_callback,
            message_types=[MessageType.STATUS],
            max_retries=1  # Only retry once
        )

        # Get the circuit breaker for the agent
        circuit_breaker = self.message_bus._circuit_breakers.get("failing_agent")
        self.assertIsNotNone(circuit_breaker)

        # Initially, the circuit should be closed
        self.assertEqual(circuit_breaker.state, CircuitState.CLOSED)

        # Publish messages until the circuit opens
        for _ in range(10):  # Should be enough to trigger the circuit breaker
            response = self.test_message.create_response(
                message_type=MessageType.STATUS,
                content={"status": "test"}
            )
            response.receiver = "failing_agent"
            self.message_bus.publish(response)

        # Check that the circuit is now open
>       self.assertEqual(circuit_breaker.state, CircuitState.OPEN)
E       AssertionError: <CircuitState.CLOSED: 1> != <CircuitState.OPEN: 2>

tests/unit/test_enhanced_message_bus.py:311: AssertionError
____________ TestEnhancedMessageBus.test_cleanup_old_conversations _____________

self = <unit.test_enhanced_message_bus.TestEnhancedMessageBus testMethod=test_cleanup_old_conversations>

    def test_cleanup_old_conversations(self):
        """Test cleanup of old conversations."""
        # Create multiple conversations
        for i in range(5):
            message = AgentMessage(
                message_type=MessageType.STATUS,
                content={"status": f"test_{i}"},
                sender="test_sender",
                conversation_id=f"conversation_{i}"
            )
            self.message_bus.publish(message)

        # Check that all conversations were created
>       self.assertEqual(len(self.message_bus._conversations), 5)
E       AssertionError: 0 != 5

tests/unit/test_enhanced_message_bus.py:532: AssertionError
_______________ TestEnhancedMessageBus.test_conversation_memory ________________

self = <unit.test_enhanced_message_bus.TestEnhancedMessageBus testMethod=test_conversation_memory>

    def test_conversation_memory(self):
        """Test conversation memory for storing message history."""
        # Subscribe to messages
        self.message_bus.subscribe(
            agent_id="test_agent",
            callback=self.mock_callback,
            message_types=[MessageType.STATUS, MessageType.QUERY, MessageType.QUERY_RESPONSE]
        )

        # Create a conversation with multiple messages
        query = AgentMessage(
            message_type=MessageType.QUERY,
            content={"query": "What is the status?"},
            sender="agent1",
            receiver="agent2"
        )

        response = query.create_response(
            message_type=MessageType.QUERY_RESPONSE,
            content={"response": "Status is normal"}
        )

        follow_up = response.create_response(
            message_type=MessageType.QUERY,
            content={"query": "Any warnings?"}
        )

        # Publish all messages
        self.message_bus.publish(query)
        self.message_bus.publish(response)
        self.message_bus.publish(follow_up)

        # Get the conversation
        conversation = self.message_bus.get_conversation(query.conversation_id)

        # Check that all messages are in the conversation
>       self.assertEqual(len(conversation.messages), 3)
                             ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'NoneType' object has no attribute 'messages'

tests/unit/test_enhanced_message_bus.py:439: AttributeError
_____________ TestEnhancedMessageBus.test_delivery_status_tracking _____________

self = <unit.test_enhanced_message_bus.TestEnhancedMessageBus testMethod=test_delivery_status_tracking>

    def test_delivery_status_tracking(self):
        """Test delivery status tracking."""
        # Subscribe to messages
        self.message_bus.subscribe(
            agent_id="test_agent",
            callback=self.mock_callback,
            message_types=[MessageType.STATUS]
        )

        # Publish a message
        self.message_bus.publish(self.test_message)

        # Get delivery status
        delivery_status = self.message_bus.get_delivery_status(self.test_message.message_id)

        # Check that delivery status was recorded
>       self.assertIn("test_agent", delivery_status)
E       AssertionError: 'test_agent' not found in {}

tests/unit/test_enhanced_message_bus.py:516: AssertionError
__________________ TestEnhancedMessageBus.test_direct_message __________________

self = <MagicMock id='140532340992976'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'mock' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_enhanced_message_bus.TestEnhancedMessageBus testMethod=test_direct_message>

    def test_direct_message(self):
        """Test sending a direct message to a specific agent."""
        # Subscribe to messages
        self.message_bus.subscribe(
            agent_id="test_receiver",
            callback=self.mock_callback,
            message_types=[MessageType.STATUS]
        )

        # Create a direct message
        direct_message = AgentMessage(
            message_type=MessageType.STATUS,
            content={"status": "direct"},
            sender="test_sender",
            receiver="test_receiver"
        )

        # Publish the message
        result = self.message_bus.publish(direct_message)

        # Check that the callback was called
>       self.mock_callback.assert_called_once()
E       AssertionError: Expected 'mock' to have been called once. Called 0 times.

tests/unit/test_enhanced_message_bus.py:107: AssertionError
______________ TestEnhancedMessageBus.test_large_message_handling ______________

self = <unit.test_enhanced_message_bus.TestEnhancedMessageBus testMethod=test_large_message_handling>

    def test_large_message_handling(self):
        """Test handling of large messages with chunking."""
        # Subscribe to messages
        self.message_bus.subscribe(
            agent_id="test_agent",
            callback=self.mock_callback,
            message_types=[MessageType.CHUNKED_MESSAGE]
        )

        # Create a large message
        large_content = {"data": "x" * 1000000}  # 1MB of data
        large_message = AgentMessage(
            message_type=MessageType.TASK_REQUEST,
            content=large_content,
            sender="test_sender",
            receiver="test_agent"
        )

        # Publish the large message
        with patch.object(self.message_bus, '_is_large_message', return_value=True):
            result = self.message_bus.publish(large_message)

        # Check that the callback was called for each chunk
>       self.assertGreater(self.mock_callback.call_count, 1)
E       AssertionError: 0 not greater than 1

tests/unit/test_enhanced_message_bus.py:374: AssertionError
______________ TestEnhancedMessageBus.test_message_deduplication _______________

self = <unit.test_enhanced_message_bus.TestEnhancedMessageBus testMethod=test_message_deduplication>

    def test_message_deduplication(self):
        """Test message deduplication to prevent processing duplicates."""
        # Subscribe to messages
        self.message_bus.subscribe(
            agent_id="test_agent",
            callback=self.mock_callback,
            message_types=[MessageType.STATUS]
        )

        # Publish the same message twice
        self.message_bus.publish(self.test_message)
        self.message_bus.publish(self.test_message)  # Duplicate

        # Check that the callback was called only once
>       self.assertEqual(self.mock_callback.call_count, 1)
E       AssertionError: 0 != 1

tests/unit/test_enhanced_message_bus.py:401: AssertionError
_________ TestEnhancedMessageBus.test_message_filtering_by_confidence __________

self = <unit.test_enhanced_message_bus.TestEnhancedMessageBus testMethod=test_message_filtering_by_confidence>

    def test_message_filtering_by_confidence(self):
        """Test message filtering by confidence level."""
        # Subscribe to messages with confidence filter
        self.message_bus.subscribe(
            agent_id="test_agent",
            callback=self.mock_callback,
            message_types=[MessageType.STATUS],
            filters={"min_confidence": 0.7}
        )

        # Create a message with high confidence
        high_confidence_message = AgentMessage(
            message_type=MessageType.STATUS,
            content={"status": "test"},
            sender="test_sender",
            confidence=0.8
        )

        # Create a message with low confidence
        low_confidence_message = AgentMessage(
            message_type=MessageType.STATUS,
            content={"status": "test"},
            sender="test_sender",
            confidence=0.5
        )

        # Publish both messages
        self.message_bus.publish(high_confidence_message)
        self.message_bus.publish(low_confidence_message)

        # Check that the callback was called only once (for the high confidence message)
>       self.assertEqual(self.mock_callback.call_count, 1)
E       AssertionError: 0 != 1

tests/unit/test_enhanced_message_bus.py:213: AssertionError
___________ TestEnhancedMessageBus.test_message_filtering_by_source ____________

self = <unit.test_enhanced_message_bus.TestEnhancedMessageBus testMethod=test_message_filtering_by_source>

    def test_message_filtering_by_source(self):
        """Test message filtering by source."""
        # Subscribe to messages with source filter
        self.message_bus.subscribe(
            agent_id="test_agent",
            callback=self.mock_callback,
            message_types=[MessageType.STATUS],
            filters={"source": "specific_sender"}
        )

        # Create a message from the specific sender
        message_from_specific = AgentMessage(
            message_type=MessageType.STATUS,
            content={"status": "test"},
            sender="specific_sender"
        )

        # Create a message from another sender
        message_from_other = AgentMessage(
            message_type=MessageType.STATUS,
            content={"status": "test"},
            sender="other_sender"
        )

        # Publish both messages
        self.message_bus.publish(message_from_specific)
        self.message_bus.publish(message_from_other)

        # Check that the callback was called only once (for the matching sender)
>       self.assertEqual(self.mock_callback.call_count, 1)
E       AssertionError: 0 != 1

tests/unit/test_enhanced_message_bus.py:176: AssertionError
____________ TestEnhancedMessageBus.test_message_filtering_by_topic ____________

self = <unit.test_enhanced_message_bus.TestEnhancedMessageBus testMethod=test_message_filtering_by_topic>

    def test_message_filtering_by_topic(self):
        """Test message filtering by topic."""
        # Subscribe to messages with topic filter
        self.message_bus.subscribe(
            agent_id="test_agent",
            callback=self.mock_callback,
            message_types=[MessageType.STATUS],
            filters={"topic": "test_topic"}
        )

        # Create a message with matching topic
        message_with_topic = AgentMessage(
            message_type=MessageType.STATUS,
            content={"status": "test"},
            sender="test_sender",
            metadata={"topic": "test_topic"}
        )

        # Create a message with non-matching topic
        message_with_other_topic = AgentMessage(
            message_type=MessageType.STATUS,
            content={"status": "test"},
            sender="test_sender",
            metadata={"topic": "other_topic"}
        )

        # Publish both messages
        self.message_bus.publish(message_with_topic)
        self.message_bus.publish(message_with_other_topic)

        # Check that the callback was called only once (for the matching topic)
>       self.assertEqual(self.mock_callback.call_count, 1)
E       AssertionError: 0 != 1

tests/unit/test_enhanced_message_bus.py:141: AssertionError
_______________ TestEnhancedMessageBus.test_performance_metrics ________________

self = <unit.test_enhanced_message_bus.TestEnhancedMessageBus testMethod=test_performance_metrics>

    def test_performance_metrics(self):
        """Test performance metrics tracking."""
        # Subscribe to messages
        self.message_bus.subscribe(
            agent_id="test_agent",
            callback=self.mock_callback,
            message_types=[MessageType.STATUS]
        )

        # Publish a message
        self.message_bus.publish(self.test_message)

        # Get performance metrics
        metrics = self.message_bus.get_performance_metrics()

        # Check that metrics were recorded
>       self.assertEqual(metrics.total_messages, 1)
E       AssertionError: 0 != 1

tests/unit/test_enhanced_message_bus.py:490: AssertionError
_____________ TestEnhancedMessageBus.test_priority_based_delivery ______________

self = <unit.test_enhanced_message_bus.TestEnhancedMessageBus testMethod=test_priority_based_delivery>

    def test_priority_based_delivery(self):
        """Test priority-based message delivery."""
        # Create a list to track the order of message delivery
        delivery_order = []

        # Create a callback that records the message priority
        def priority_callback(message):
            priority = message.metadata.get("priority", "unknown")
            delivery_order.append(priority)

        # Subscribe to messages
        self.message_bus.subscribe(
            agent_id="test_agent",
            callback=priority_callback,
            message_types=[MessageType.STATUS]
        )

        # Create messages with different priorities
        low_priority_message = AgentMessage(
            message_type=MessageType.STATUS,
            content={"status": "low"},
            sender="test_sender",
            metadata={"priority": "low"}
        )

        high_priority_message = AgentMessage(
            message_type=MessageType.STATUS,
            content={"status": "high"},
            sender="test_sender",
            metadata={"priority": "high"}
        )

        critical_priority_message = AgentMessage(
            message_type=MessageType.STATUS,
            content={"status": "critical"},
            sender="test_sender",
            metadata={"priority": "critical"}
        )

        # Publish messages with different priorities
        self.message_bus.publish(
            low_priority_message,
            priority=MessagePriority.LOW
        )

        self.message_bus.publish(
            high_priority_message,
            priority=MessagePriority.HIGH
        )

        self.message_bus.publish(
            critical_priority_message,
            priority=MessagePriority.CRITICAL
        )

        # Check that messages were delivered in priority order
        # Note: This is a simplification, as the actual delivery order depends on
        # the implementation details of the message bus and may not be strictly
        # priority-ordered in all cases.
>       self.assertEqual(len(delivery_order), 3)
E       AssertionError: 0 != 3

tests/unit/test_enhanced_message_bus.py:278: AssertionError
______________ TestEnhancedMessageBus.test_subscribe_and_publish _______________

self = <MagicMock id='140532341464512'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'mock' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_enhanced_message_bus.TestEnhancedMessageBus testMethod=test_subscribe_and_publish>

    def test_subscribe_and_publish(self):
        """Test basic subscription and publishing."""
        # Subscribe to messages
        self.message_bus.subscribe(
            agent_id="test_agent",
            callback=self.mock_callback,
            message_types=[MessageType.STATUS]
        )

        # Publish a message
        result = self.message_bus.publish(self.test_message)

        # Check that the callback was called
>       self.mock_callback.assert_called_once()
E       AssertionError: Expected 'mock' to have been called once. Called 0 times.

tests/unit/test_enhanced_message_bus.py:62: AssertionError
____________ TestEnhancedMessageBus.test_thought_chain_integration _____________

self = <unit.test_enhanced_message_bus.TestEnhancedMessageBus testMethod=test_thought_chain_integration>

    def test_thought_chain_integration(self):
        """Test integration with thought chains."""
        # Create a thought chain manager
        thought_chain_manager = ThoughtChainManager()

        # Create a message bus with thought chain integration
        message_bus_with_tc = EnhancedMessageBus(thought_chain_manager=thought_chain_manager)

        # Subscribe to messages
        message_bus_with_tc.subscribe(
            agent_id="test_agent",
            callback=self.mock_callback,
            message_types=[MessageType.STATUS]
        )

        # Publish a message
        message_bus_with_tc.publish(self.test_message)

        # Check that a thought chain was created
        thought_chain = message_bus_with_tc.get_thought_chain(self.test_message.conversation_id)
>       self.assertIsNotNone(thought_chain)
E       AssertionError: unexpectedly None

tests/unit/test_enhanced_message_bus.py:469: AssertionError
_________________ TestEnhancedMessageBus.test_timeout_handling _________________

self = <unit.test_enhanced_message_bus.TestEnhancedMessageBus testMethod=test_timeout_handling>

    def test_timeout_handling(self):
        """Test timeout handling for message delivery."""
        # Create a callback that sleeps longer than the timeout
        def slow_callback(message):
            time.sleep(0.2)  # Sleep for 200ms

        # Subscribe to messages with the slow callback and a short timeout
        self.message_bus.subscribe(
            agent_id="slow_agent",
            callback=slow_callback,
            message_types=[MessageType.STATUS],
            timeout=0.1  # 100ms timeout
        )

        # Publish a message
        response = self.test_message.create_response(
            message_type=MessageType.STATUS,
            content={"status": "test"}
        )
        response.receiver = "slow_agent"
        result = self.message_bus.publish(response)

        # Check that the delivery failed due to timeout
>       self.assertFalse(result["delivery_status"]["slow_agent"]["success"])
                         ^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: 'coroutine' object is not subscriptable

tests/unit/test_enhanced_message_bus.py:342: TypeError
_________________ TestFeedbackCollector.test_analyze_feedback __________________

self = <unit.test_feedback_collector.TestFeedbackCollector testMethod=test_analyze_feedback>

    def test_analyze_feedback(self):
        """Test analyzing feedback."""
        # Record multiple feedback entries
        self.collector.record_feedback(
            content="Bug in login",
            feedback_type="bug",
            rating=2,
            tags=["login", "critical"]
        )

        self.collector.record_feedback(
            content="Feature request: Dark mode",
            feedback_type="feature",
            rating=4,
            tags=["ui", "dark-mode"]
        )

        self.collector.record_feedback(
            content="Another bug in login",
            feedback_type="bug",
            rating=3,
            tags=["login", "medium"]
        )

        # Analyze all feedback
        analysis = self.collector.analyze_feedback()

        # Check the analysis results
        self.assertEqual(analysis['total_count'], 3)
        self.assertEqual(len(analysis['by_type']), 2)
        self.assertEqual(analysis['by_type']['bug'], 2)
        self.assertEqual(analysis['by_type']['feature'], 1)
        self.assertIsNotNone(analysis['average_rating'])
        self.assertEqual(analysis['processed_count'], 0)
        self.assertEqual(analysis['unprocessed_count'], 3)
>       self.assertEqual(len(analysis['common_tags']), 4)
E       AssertionError: 5 != 4

tests/unit/test_feedback_collector.py:254: AssertionError
_______________ TestFeedbackCollector.test_export_feedback_json ________________

self = <unit.test_feedback_collector.TestFeedbackCollector testMethod=test_export_feedback_json>
mock_file = <MagicMock name='open' id='140532341744768'>

    @patch('builtins.open', new_callable=mock_open)
    def test_export_feedback_json(self, mock_file):
        """Test exporting feedback to JSON."""
        # Record feedback
        self.collector.record_feedback(
            content="Test feedback",
            feedback_type="bug"
        )

        # Export to JSON
        success = self.collector.export_feedback("test.json", format="json")

        # Check that the export was successful
        self.assertTrue(success)

        # Check that the file was opened for writing
        mock_file.assert_called_once_with("test.json", "w")

        # Check that json.dump was called with the feedback data
        handle = mock_file()
>       self.assertEqual(handle.write.call_count, 1)
E       AssertionError: 42 != 1

tests/unit/test_feedback_collector.py:285: AssertionError
______________________________ test_fsync_mocked _______________________________

mocker = <pytest_mock.plugin.MockerFixture object at 0x7fd03c0fe900>

    def test_fsync_mocked(mocker):
        """Test that fsync is called by atomic_write."""
        mock_os_fsync = mocker.patch("os.fsync")
        # If using libc directly: mock_libc_fsync = mocker.patch("triangulum_lx.tooling.fs_ops.c_fsync")

        test_file = BASE_TEST_DIR / "test_fsync.txt"
        data = b"fsync test"

        # Test with fallback (tempfile + rename)
        fs_ops.atomic_write(str(test_file), data, use_otmpfile_if_available=False)
        mock_os_fsync.assert_called() # Should be called on the temp file descriptor
        # If also testing O_TMPFILE path, would need to ensure it's called there too.
        # This is tricky because O_TMPFILE path might not be taken.
        # For now, testing fsync on fallback is sufficient to show integration.

        # Reset mock for another call if testing O_TMPFILE path separately
        mock_os_fsync.reset_mock()
>       if fs_ops.os.name == 'posix' and hasattr(fs_ops.os, 'O_TMPFILE') and hasattr(fs_ops.os, 'linkat'):
           ^^^^^^^^^
E       AttributeError: module 'triangulum_lx.tooling.fs_ops' has no attribute 'os'

tests/unit/test_fs_ops.py:291: AttributeError
______________ TestPriorityAnalyzerAgent.test_analyze_priorities _______________

self = <unit.test_priority_analyzer_agent.TestPriorityAnalyzerAgent testMethod=test_analyze_priorities>

    def test_analyze_priorities(self):
        bugs_by_file = {
            "file1.py": [{"severity": "high"}, {"severity": "low"}],
            "file2.py": [{"severity": "critical"}],
        }
        relationships = {
            "file1.py": {"dependencies": ["file2.py"], "dependents": []},
            "file2.py": {"dependencies": [], "dependents": ["file1.py"]},
        }

        priorities = self.agent.analyze_priorities("dummy_path", bugs_by_file, relationships)

        self.assertIn("file1.py", priorities)
        self.assertIn("file2.py", priorities)
>       self.assertGreater(priorities["file1.py"]["priority"], priorities["file2.py"]["priority"])
E       AssertionError: 0.6494303829603245 not greater than 0.6605

tests/unit/test_priority_analyzer_agent.py:29: AssertionError
_______ TestPriorityAnalyzerAgent.test_handle_priority_analysis_request ________

self = <MagicMock name='mock.publish' id='140532338000240'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'publish' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_priority_analyzer_agent.TestPriorityAnalyzerAgent testMethod=test_handle_priority_analysis_request>

    def test_handle_priority_analysis_request(self):
        message = AgentMessage(
            message_type=MessageType.TASK_REQUEST,
            sender="test_agent",
            content={
                "action": "analyze_priorities",
                "folder_path": "/path/to/folder",
                "bugs_by_file": {"file1.py": []},
                "relationships": {},
            },
        )
        self.agent.handle_message(message)
>       self.message_bus.publish.assert_called_once()
E       AssertionError: Expected 'publish' to have been called once. Called 0 times.

tests/unit/test_priority_analyzer_agent.py:43: AssertionError
______________ TestRelationshipAnalystAgent.test_analyze_codebase ______________

self = <unit.test_relationship_analyst_agent.TestRelationshipAnalystAgent testMethod=test_analyze_codebase>

    def test_analyze_codebase(self):
        """Test analyzing a codebase."""
        # Create a test project
        self.create_test_project()

        # Mock the build_graph method to avoid actual file system operations
        with patch('triangulum_lx.tooling.dependency_graph.DependencyGraphBuilder.build_graph', return_value=self.graph):
            # Analyze the codebase
>           summary = self.agent.analyze_codebase(self.temp_dir)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/test_relationship_analyst_agent.py:147:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <triangulum_lx.agents.relationship_analyst_agent.RelationshipAnalystAgent object at 0x7fd03c1c2300>
root_dir = '/tmp/tmpe5qd7e6c', include_patterns = None, exclude_patterns = None
incremental = True, analyze_runtime_traces = False, save_report = True
report_path = None

    def analyze_codebase(
        self,
        root_dir: str,
        include_patterns: Optional[List[str]] = None,
        exclude_patterns: Optional[List[str]] = None,
        incremental: bool = True,
        # perform_static_analysis: bool = True, # This will be simplified/removed
        analyze_runtime_traces: bool = False,
        save_report: bool = True,
        report_path: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Analyze the codebase to determine relationships between files.

        Args:
            root_dir: Root directory of the codebase
            include_patterns: List of glob patterns to include
            exclude_patterns: List of glob patterns to exclude
            incremental: Whether to perform incremental analysis
            perform_static_analysis: Whether to perform static analysis
            analyze_runtime_traces: Whether to analyze runtime traces
            save_report: Whether to save the analysis report
            report_path: Path to save the analysis report

        Returns:
            Dictionary with analysis summary
        """
        logger.info(f"Analyzing codebase at {root_dir}...")

        # Set up dependency graph builder
        builder = DependencyGraphBuilder(cache_dir=self.cache_dir)

        # Store the previous graph for incremental analysis and historical tracking
        previous_graph = self.graph

        # Perform analysis
        if incremental and previous_graph:
            # Incremental analysis
            self.graph = builder.build_graph(
                root_dir,
                include_patterns=include_patterns,
                exclude_patterns=exclude_patterns,
                previous_graph=previous_graph,
                incremental=True
            )
        else:
            # Full analysis
            self.graph = builder.build_graph(
                root_dir,
                include_patterns=include_patterns,
                exclude_patterns=exclude_patterns,
                incremental=False
            )

        # Save the previous graph for historical tracking
        if previous_graph:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            self.historical_graphs.append((timestamp, previous_graph))

            # Keep only the last 10 historical graphs
            if len(self.historical_graphs) > 10:
                self.historical_graphs.pop(0)

        # Update analysis time
        self.last_analysis_time = time.time()

        # _enhance_with_static_analysis (using CodeRelationshipAnalyzer) is removed for now.
        # The new DependencyGraphBuilder and its parsers (esp. PythonDependencyParser)
        # already perform AST-based import analysis. Deeper static analysis like call graphs
        # would be a future enhancement to the parsers or a new specialized analyzer.

        # Incorporate runtime traces if requested
        if analyze_runtime_traces and self.execution_traces:
            self._incorporate_runtime_traces() # This method might need adjustment if graph structure changed

        # Create an analyzer for the graph
        # The self.graph is now an instance of our stubbed DependencyGraph.
        # The DependencyAnalyzer (from tooling.dependency_analyzer) takes this.
        self.analyzer = DependencyAnalyzer(self.graph)

        # Return a summary
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

        # Adjust summary to reflect new graph structure if needed
        # self.graph is DependencyGraph, self.analyzer.nx_graph is networkx
        num_nodes = len(self.analyzer.nx_graph.nodes()) if self.analyzer and self.analyzer.nx_graph else 0
        num_edges = len(self.analyzer.nx_graph.edges()) if self.analyzer and self.analyzer.nx_graph else 0
>       num_cycles = len(self.analyzer.find_cycles()) if self.analyzer else 0
                         ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DependencyAnalyzer' object has no attribute 'find_cycles'

triangulum_lx/agents/relationship_analyst_agent.py:175: AttributeError
_______________ TestRelationshipAnalystAgent.test_error_handling _______________

self = <MagicMock name='mock.publish' id='140532337730448'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'publish' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_relationship_analyst_agent.TestRelationshipAnalystAgent testMethod=test_error_handling>

    def test_error_handling(self):
        """Test error handling in message processing."""
        # Create a mock message with an invalid query type
        message = AgentMessage(
            message_type=MessageType.QUERY,
            content={
                "query_type": "invalid_query"
            },
            sender="test_sender"
        )

        # Handle the message
        self.agent._handle_query(message)

        # Verify that send_response was called with an error message
>       self.agent.message_bus.publish.assert_called_once()
E       AssertionError: Expected 'publish' to have been called once. Called 0 times.

tests/unit/test_relationship_analyst_agent.py:320: AssertionError
________________ TestRelationshipAnalystAgent.test_find_cycles _________________

self = <unit.test_relationship_analyst_agent.TestRelationshipAnalystAgent testMethod=test_find_cycles>

    def test_find_cycles(self):
        """Test finding cycles in the dependency graph."""
        # Find cycles
>       cycles = self.agent.find_cycles()
                 ^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/test_relationship_analyst_agent.py:169:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <triangulum_lx.agents.relationship_analyst_agent.RelationshipAnalystAgent object at 0x7fd03c15d160>

    def find_cycles(self) -> List[List[str]]:
        """
        Find cycles in the dependency graph.

        Returns:
            List of cycles (each cycle is a list of file paths)
        """
        if not self.analyzer:
            raise ValueError("No analysis has been performed yet. Call analyze_codebase first.")

>       return self.analyzer.find_cycles()
               ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DependencyAnalyzer' object has no attribute 'find_cycles'

triangulum_lx/agents/relationship_analyst_agent.py:221: AttributeError
___________ TestRelationshipAnalystAgent.test_get_file_dependencies ____________

self = <unit.test_relationship_analyst_agent.TestRelationshipAnalystAgent testMethod=test_get_file_dependencies>

    def test_get_file_dependencies(self):
        """Test getting file dependencies."""
        # Get direct dependencies of file1.py
        dependencies = self.agent.get_file_dependencies("file1.py")
        self.assertEqual(len(dependencies), 2)
        self.assertIn("file2.py", dependencies)
        self.assertIn("file3.py", dependencies)

        # Get transitive dependencies of file1.py
>       dependencies = self.agent.get_file_dependencies("file1.py", transitive=True)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/test_relationship_analyst_agent.py:200:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <triangulum_lx.agents.relationship_analyst_agent.RelationshipAnalystAgent object at 0x7fd03c18f650>
file_path = 'file1.py', transitive = True

    def get_file_dependencies(self, file_path: str, transitive: bool = False) -> Set[str]:
        """
        Get files that the specified file depends on.

        Args:
            file_path: Path to the file
            transitive: Whether to include transitive dependencies

        Returns:
            Set of file paths that the specified file depends on
        """
        if not self.analyzer or not self.analyzer.nx_graph: # Check analyzer and its nx_graph
            raise ValueError("No analysis has been performed yet. Call analyze_codebase first.")

        if file_path not in self.analyzer.nx_graph:
            return set()
        if transitive:
            # nx.descendants gives all nodes reachable from file_path
            # In a graph where A -> B means A imports B, descendants are dependencies.
>           return set(nx.descendants(self.analyzer.nx_graph, file_path))
                       ^^
E           NameError: name 'nx' is not defined

triangulum_lx/agents/relationship_analyst_agent.py:266: NameError
____________ TestRelationshipAnalystAgent.test_get_file_dependents _____________

self = <unit.test_relationship_analyst_agent.TestRelationshipAnalystAgent testMethod=test_get_file_dependents>

    def test_get_file_dependents(self):
        """Test getting file dependents."""
        # Get direct dependents of file2.py
        dependents = self.agent.get_file_dependents("file2.py")
        self.assertEqual(len(dependents), 1)
        self.assertIn("file1.py", dependents)

        # Get transitive dependents of file2.py
>       dependents = self.agent.get_file_dependents("file2.py", transitive=True)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/test_relationship_analyst_agent.py:188:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <triangulum_lx.agents.relationship_analyst_agent.RelationshipAnalystAgent object at 0x7fd03c03b770>
file_path = 'file2.py', transitive = True

    def get_file_dependents(self, file_path: str, transitive: bool = False) -> Set[str]:
        """
        Get files that depend on the specified file.

        Args:
            file_path: Path to the file
            transitive: Whether to include transitive dependents

        Returns:
            Set of file paths that depend on the specified file
        """
        if not self.analyzer or not self.analyzer.nx_graph: # Check analyzer and its nx_graph
            raise ValueError("No analysis has been performed yet. Call analyze_codebase first.")

        # Uses the networkx graph from the analyzer
        if file_path not in self.analyzer.nx_graph:
             return set()
        if transitive:
            # nx.ancestors gives all nodes that have a path to file_path
            # In a graph where A -> B means A imports B, ancestors are dependents.
>           return set(nx.ancestors(self.analyzer.nx_graph, file_path))
                       ^^
E           NameError: name 'nx' is not defined

triangulum_lx/agents/relationship_analyst_agent.py:243: NameError
_____________ TestRelationshipAnalystAgent.test_get_impacted_files _____________

self = <unit.test_relationship_analyst_agent.TestRelationshipAnalystAgent testMethod=test_get_impacted_files>

    def test_get_impacted_files(self):
        """Test getting impacted files."""
        # Get files impacted by changes to file2.py
>       impacted = self.agent.get_impacted_files(["file2.py"])
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'RelationshipAnalystAgent' object has no attribute 'get_impacted_files'

tests/unit/test_relationship_analyst_agent.py:223: AttributeError
_________ TestRelationshipAnalystAgent.test_handle_query_central_files _________

self = <triangulum_lx.agents.relationship_analyst_agent.RelationshipAnalystAgent object at 0x7fd03c0a9880>
message = AgentMessage(message_type=<MessageType.QUERY: 'query'>, content={'query_type': 'central_files', 'n': 2, 'metric': 'pag...chunk_sequence=None, response_id=None, compressed=False, problem_context={}, analysis_results={}, suggested_actions=[])

    def _handle_query(self, message: AgentMessage) -> Optional[AgentMessage]:
        """
        Handle a query message from another agent.

        Args:
            message: The query message to handle

        Returns:
            Response message, if any
        """
        content = message.content
        if not isinstance(content, dict):
            return None

        query_type = content.get("query_type", "")

        if query_type == "central_files":
            n = content.get("n", 10)
            metric = content.get("metric", "pagerank")

            try:
                central_files = self.get_most_central_files(n=n, metric=metric)

                return AgentMessage(
                    sender_id=self.agent_id,
>                   recipient_id=message.sender_id,
                                 ^^^^^^^^^^^^^^^^^
                    message_type=MessageType.RESPONSE,
                    content={
                        "status": "success",
                        "central_files": central_files
                    }
                )
E               AttributeError: 'AgentMessage' object has no attribute 'sender_id'. Did you mean: 'sender'?

triangulum_lx/agents/relationship_analyst_agent.py:593: AttributeError

During handling of the above exception, another exception occurred:

self = <unit.test_relationship_analyst_agent.TestRelationshipAnalystAgent testMethod=test_handle_query_central_files>

    def test_handle_query_central_files(self):
        """Test handling a query for central files."""
        # Create a mock message
        message = AgentMessage(
            message_type=MessageType.QUERY,
            content={
                "query_type": "central_files",
                "n": 2,
                "metric": "pagerank"
            },
            sender="test_sender"
        )

        # Mock the get_most_central_files method
        with patch.object(self.agent, 'get_most_central_files', return_value=[("file1.py", 0.5), ("file5.py", 0.3)]):
            # Handle the message
>           self.agent._handle_query(message)

tests/unit/test_relationship_analyst_agent.py:268:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <triangulum_lx.agents.relationship_analyst_agent.RelationshipAnalystAgent object at 0x7fd03c0a9880>
message = AgentMessage(message_type=<MessageType.QUERY: 'query'>, content={'query_type': 'central_files', 'n': 2, 'metric': 'pag...chunk_sequence=None, response_id=None, compressed=False, problem_context={}, analysis_results={}, suggested_actions=[])

    def _handle_query(self, message: AgentMessage) -> Optional[AgentMessage]:
        """
        Handle a query message from another agent.

        Args:
            message: The query message to handle

        Returns:
            Response message, if any
        """
        content = message.content
        if not isinstance(content, dict):
            return None

        query_type = content.get("query_type", "")

        if query_type == "central_files":
            n = content.get("n", 10)
            metric = content.get("metric", "pagerank")

            try:
                central_files = self.get_most_central_files(n=n, metric=metric)

                return AgentMessage(
                    sender_id=self.agent_id,
                    recipient_id=message.sender_id,
                    message_type=MessageType.RESPONSE,
                    content={
                        "status": "success",
                        "central_files": central_files
                    }
                )
            except Exception as e:
                return AgentMessage(
                    sender_id=self.agent_id,
>                   recipient_id=message.sender_id,
                                 ^^^^^^^^^^^^^^^^^
                    message_type=MessageType.RESPONSE,
                    content={
                        "status": "error",
                        "error": str(e)
                    }
                )
E               AttributeError: 'AgentMessage' object has no attribute 'sender_id'. Did you mean: 'sender'?

triangulum_lx/agents/relationship_analyst_agent.py:603: AttributeError
_______ TestRelationshipAnalystAgent.test_handle_query_file_dependencies _______

self = <MagicMock name='mock.publish' id='140532337603792'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'publish' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_relationship_analyst_agent.TestRelationshipAnalystAgent testMethod=test_handle_query_file_dependencies>

    def test_handle_query_file_dependencies(self):
        """Test handling a query for file dependencies."""
        # Create a mock message
        message = AgentMessage(
            message_type=MessageType.QUERY,
            content={
                "query_type": "file_dependencies",
                "file_path": "file1.py",
                "transitive": False
            },
            sender="test_sender"
        )

        # Mock the get_file_dependencies method
        with patch.object(self.agent, 'get_file_dependencies', return_value={"file2.py", "file3.py"}):
            # Handle the message
            self.agent._handle_query(message)

            # Verify that send_response was called with the correct arguments
>           self.agent.message_bus.publish.assert_called_once()
E           AssertionError: Expected 'publish' to have been called once. Called 0 times.

tests/unit/test_relationship_analyst_agent.py:297: AssertionError
____ TestRelationshipAnalystAgent.test_handle_task_request_analyze_codebase ____

self = <MagicMock name='mock.publish' id='140532337764944'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'publish' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_relationship_analyst_agent.TestRelationshipAnalystAgent testMethod=test_handle_task_request_analyze_codebase>

    def test_handle_task_request_analyze_codebase(self):
        """Test handling a task request to analyze a codebase."""
        # Create a mock message
        message = AgentMessage(
            message_type=MessageType.TASK_REQUEST,
            content={
                "action": "analyze_codebase",
                "root_dir": self.temp_dir
            },
            sender="test_sender"
        )

        # Mock the analyze_codebase method
        with patch.object(self.agent, 'analyze_codebase', return_value={"files_analyzed": 5}):
            # Handle the message
            self.agent._handle_task_request(message)

            # Verify that send_response was called with the correct arguments
>           self.agent.message_bus.publish.assert_called_once()
E           AssertionError: Expected 'publish' to have been called once. Called 0 times.

tests/unit/test_relationship_analyst_agent.py:246: AssertionError
________ TestRelationshipAnalystAgent.test_prioritize_files_for_repair _________

self = <unit.test_relationship_analyst_agent.TestRelationshipAnalystAgent testMethod=test_prioritize_files_for_repair>

    def test_prioritize_files_for_repair(self):
        """Test prioritizing files for repair."""
        # Prioritize all files
>       priorities = self.agent.prioritize_files_for_repair()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'RelationshipAnalystAgent' object has no attribute 'prioritize_files_for_repair'

tests/unit/test_relationship_analyst_agent.py:211: AttributeError
______________ TestRelationshipAnalystAgent.test_process_message _______________

self = <unit.test_relationship_analyst_agent.TestRelationshipAnalystAgent testMethod=test_process_message>

    def test_process_message(self):
        """Test the process_message method."""
        # Test with a valid action
        with patch.object(self.agent, 'analyze_codebase', return_value={"files_analyzed": 5}):
            result = self.agent.process_message({
                "action": "analyze_codebase",
                "root_dir": self.temp_dir
            })

            self.assertEqual(result["status"], "success")
            self.assertEqual(result["summary"]["files_analyzed"], 5)

        # Test with an invalid action
        result = self.agent.process_message({
            "action": "invalid_action"
        })

        self.assertEqual(result["status"], "error")
>       self.assertIn("Unknown action", result["message"])
                                        ^^^^^^^^^^^^^^^^^
E       KeyError: 'message'

tests/unit/test_relationship_analyst_agent.py:344: KeyError
______________ TestResponseHandling.test_chunking_and_reassembly _______________

self = <unit.test_response_handling.TestResponseHandling testMethod=test_chunking_and_reassembly>

    def test_chunking_and_reassembly(self):
        """Test chunking and reassembling messages."""
        # Create a message with large content
        large_content = {"data": ["item" * 50 for _ in range(50)]}
        original_message = AgentMessage(
            message_id="test_chunking",
            message_type=MessageType.TASK_RESULT,
            content=large_content,
            sender="sender",
            receiver="receiver",
            timestamp=time.time()
        )

        # Chunk the message
        chunks = self.chunker.chunk_message(original_message)
        self.assertGreater(len(chunks), 1)

        # Reassemble the chunks
        reassembled = self.chunker.reassemble_chunks(chunks)

        # Verify the reassembled message
        self.assertEqual(reassembled.message_id, original_message.message_id)
        self.assertEqual(reassembled.message_type, original_message.message_type)
>       self.assertEqual(len(reassembled.content["data"]), len(original_message.content["data"]))
                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'data'

tests/unit/test_response_handling.py:63: KeyError
_______________ TestResponseHandling.test_large_response_handler _______________

self = <unit.test_response_handling.TestResponseHandling testMethod=test_large_response_handler>

    def test_large_response_handler(self):
        """Test the complete large response handler."""
        # Create a message with large content
        large_content = {"data": ["item" * 100 for _ in range(100)]}
        original_message = AgentMessage(
            message_id="test_large_handler",
            message_type=MessageType.TASK_RESULT,
            content=large_content,
            sender="sender",
            receiver="receiver",
            timestamp=time.time()
        )

        # Process outgoing message with chunking
        message_ids = self.handler.process_outgoing_message(
            original_message,
            large_content_handling="chunked"
        )

        # Verify multiple chunks were published
>       self.assertGreater(len(message_ids), 1)
E       AssertionError: 1 not greater than 1

tests/unit/test_response_handling.py:170: AssertionError
_____________________ TestResponseHandling.test_validation _____________________

self = <unit.test_response_handling.TestResponseHandling testMethod=test_validation>

    def test_validation(self):
        """Test message validation."""
        # Valid message
        valid_message = AgentMessage(
            message_id="test_valid",
            message_type=MessageType.TASK_RESULT,
            content={"result": "valid"},
            sender="sender",
            receiver="receiver",
            timestamp=time.time()
        )

        is_valid, error = self.validator.validate_response(valid_message)
        self.assertTrue(is_valid)
        self.assertIsNone(error)

        # Invalid message (missing sender)
>       invalid_message = AgentMessage(
            message_id="test_invalid",
            message_type=MessageType.TASK_RESULT,
            content={"result": "invalid"},
            sender=None,
            receiver="receiver",
            timestamp=time.time()
        )

tests/unit/test_response_handling.py:109:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:23: in __init__
    ???
triangulum_lx/agents/message.py:134: in __post_init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = AgentMessage(message_type=<MessageType.TASK_RESULT: 'task_result'>, content={'result': 'invalid'}, sender=None, messag...chunk_sequence=None, response_id=None, compressed=False, problem_context={}, analysis_results={}, suggested_actions=[])

    def validate(self) -> bool:
        """
        Validate the message structure and content.

        Returns:
            bool: True if the message is valid, raises ValueError otherwise
        """
        if not isinstance(self.message_type, MessageType):
            raise ValueError(f"message_type must be a MessageType enum, got {type(self.message_type)}")
        try:
            # Import here to avoid circular imports
            from triangulum_lx.agents.message_schema import validate_message

            # Convert to dict for validation
            message_dict = self.to_dict()

            # Validate against schema
            is_valid, errors = validate_message(message_dict)

            if not is_valid:
                error_msg = "; ".join(errors)
>               raise ValueError(f"Message validation failed: {error_msg}")
E               ValueError: Message validation failed: Field 'sender' is required

triangulum_lx/agents/message.py:161: ValueError
_________________ TestStrategyAgent.test_handle_error_messages _________________

self = <MagicMock name='mock.publish' id='140532338211968'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'publish' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_strategy_agent.TestStrategyAgent testMethod=test_handle_error_messages>

    def test_handle_error_messages(self):
        """Test handling error cases."""
        # Test with invalid action
        message = AgentMessage(
            message_type=MessageType.TASK_REQUEST,
            content={
                "action": "invalid_action"
            },
            sender="test_sender"
        )

        # Handle the message
        self.agent._handle_task_request(message)

        # Verify that send_response was called with an error message
>       self.agent.message_bus.publish.assert_called_once()
E       AssertionError: Expected 'publish' to have been called once. Called 0 times.

tests/unit/test_strategy_agent.py:231: AssertionError
__________ TestStrategyAgent.test_handle_query_get_strategy_templates __________

self = <MagicMock name='mock.publish' id='140532342258192'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'publish' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_strategy_agent.TestStrategyAgent testMethod=test_handle_query_get_strategy_templates>

    def test_handle_query_get_strategy_templates(self):
        """Test handling a query for strategy templates."""
        message = AgentMessage(
            message_type=MessageType.QUERY,
            content={
                "query_type": "get_strategy_templates",
                "bug_type": "null_pointer"
            },
            sender="test_sender"
        )

        # Handle the message
        self.agent._handle_query(message)

        # Verify that send_response was called with the correct arguments
>       self.agent.message_bus.publish.assert_called_once()
E       AssertionError: Expected 'publish' to have been called once. Called 0 times.

tests/unit/test_strategy_agent.py:209: AssertionError
________ TestStrategyAgent.test_handle_task_request_formulate_strategy _________

self = <MagicMock name='mock.publish' id='140532342792000'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'publish' to have been called once. Called 0 times.

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = <unit.test_strategy_agent.TestStrategyAgent testMethod=test_handle_task_request_formulate_strategy>

    def test_handle_task_request_formulate_strategy(self):
        """Test handling a task request to formulate a strategy."""
        bug_report = {
            "pattern_id": "null_pointer",
            "file": "test.py",
            "line": 10,
            "code": "result = data.get_value()",
            "description": "Potential null/None reference",
            "severity": "high"
        }

        code_context = {
            "language": "python",
            "file_content": "def process(data):\n    result = data.get_value()\n    return result"
        }

        message = AgentMessage(
            message_type=MessageType.TASK_REQUEST,
            content={
                "action": "formulate_strategy",
                "bug_report": bug_report,
                "code_context": code_context
            },
            sender="test_sender"
        )

        # Handle the message
        self.agent._handle_task_request(message)

        # Verify that send_response was called with the correct arguments
>       self.agent.message_bus.publish.assert_called_once()
E       AssertionError: Expected 'publish' to have been called once. Called 0 times.

tests/unit/test_strategy_agent.py:188: AssertionError
_____________________ TestSystemMonitor.test_check_health ______________________

args = (<unit.test_system_monitor.TestSystemMonitor testMethod=test_check_health>,)
keywargs = {}
newargs = (<unit.test_system_monitor.TestSystemMonitor testMethod=test_check_health>, <MagicMock name='disk_usage' id='140532407...40532341473152'>, <MagicMock name='cpu_times' id='140532341750960'>, <MagicMock name='cpu_times' id='140532340883376'>)
newkeywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
        with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):
>           return func(*newargs, **newkeywargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: TestSystemMonitor.test_check_health() takes 5 positional arguments but 6 were given

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:1396: TypeError
____________________ TestSystemMonitor.test_export_metrics _____________________

self = <unit.test_system_monitor.TestSystemMonitor testMethod=test_export_metrics>
mock_json_dumps = <MagicMock name='dumps' id='140532337518752'>
mock_open = <MagicMock name='open' id='140532337519520'>

    @patch('builtins.open')
    @patch('json.dumps')
    def test_export_metrics(self, mock_json_dumps, mock_open):
        """Test exporting metrics."""
        # Set up test metrics
        self.monitor.metrics = {
            'timestamp': time.time(),
            'cpu_percent': 50.0,
            'memory_percent': 60.0,
            'disk_percent': 70.0,
            'warnings': [],
            'errors': []
        }
        mock_json_dumps.return_value = '{"metrics": "test"}'

        # Export metrics to JSON
>       result = self.monitor.export_metrics(output_format='json')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/test_system_monitor.py:213:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
triangulum_lx/monitoring/system_monitor.py:298: in export_metrics
    self.check_health()
triangulum_lx/monitoring/system_monitor.py:103: in check_health
    cpu_percent = psutil.cpu_percent(interval=0.1)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/site-packages/psutil/__init__.py:1813: in cpu_percent
    t1 = cpu_times()
         ^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.11/lib/python3.12/site-packages/psutil/__init__.py:1681: in cpu_times
    return _psplatform.cpu_times()
           ^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def cpu_times():
        """Return a named tuple representing the following system-wide
        CPU times:
        (user, nice, system, idle, iowait, irq, softirq [steal, [guest,
         [guest_nice]]])
        Last 3 fields may not be available on all Linux kernel versions.
        """
        procfs_path = get_procfs_path()
        set_scputimes_ntuple(procfs_path)
        with open_binary(f"{procfs_path}/stat") as f:
            values = f.readline().split()
        fields = values[1 : len(scputimes._fields) + 1]
        fields = [float(x) / CLOCK_TICKS for x in fields]
>       return scputimes(*fields)
               ^^^^^^^^^^^^^^^^^^
E       TypeError: scputimes.__new__() missing 10 required positional arguments: 'user', 'nice', 'system', 'idle', 'iowait', 'irq', 'softirq', 'steal', 'guest', and 'guest_nice'

/home/jules/.pyenv/versions/3.12.11/lib/python3.12/site-packages/psutil/_pslinux.py:558: TypeError
______ TestOrchestratorTimeoutHandling.test_orchestrator_timeout_handling ______

self = <unit.test_timeout_handling.TestOrchestratorTimeoutHandling testMethod=test_orchestrator_timeout_handling>

    def test_orchestrator_timeout_handling(self): # Removed mock_message_bus from signature
        """Test that OrchestratorAgent properly handles timeouts."""
        # Create a mock engine monitor
        engine_monitor = MagicMock()
        mock_enhanced_message_bus = MagicMock(spec=EnhancedMessageBus)

        # Create an orchestrator instance with the mock monitor and faster internal timing
        orchestrator_config = {
            "timeout": 0.2,  # Task processing timeout
            "task_check_interval": 0.01, # How often main loop checks queue
            "progress_update_interval": 0.01, # How often progress/timeout thread runs
            "default_task_timeout": 0.2, # Default for tasks if not specified
            "timeout_grace_period": 0.05 # Grace before hard fail
        }
        orchestrator = OrchestratorAgent(
            agent_id="test_orchestrator",
            message_bus=mock_enhanced_message_bus, # Pass mock EnhancedMessageBus
            engine_monitor=engine_monitor,
            config=orchestrator_config
        )

        # Mock the _assign_task_to_agent method to avoid agent registry dependency
        orchestrator._assign_task_to_agent = MagicMock(return_value="test_agent")

        # Patch the _process_file_healing_task method to simulate a long-running task
        original_process = orchestrator._handle_folder_healing

        def slow_process(*args, **kwargs):
            time.sleep(1.0)  # Sleep longer than the timeout
            return original_process(*args, **kwargs)

        orchestrator._process_file_healing_task = slow_process

        # Create a task that will timeout
>       task_id = orchestrator.enqueue_task(
                  ^^^^^^^^^^^^^^^^^^^^^^^^^
            task_type="file_healing",
            content={"file_path": "test.py"},
            priority=TaskPriority.HIGH,
            timeout_seconds=0.5
        )
E       AttributeError: 'OrchestratorAgent' object has no attribute 'enqueue_task'

tests/unit/test_timeout_handling.py:418: AttributeError
____________________ TestSimpleBug.test_bug_resolution_flow ____________________

self = <triangulum_lx.tests.smoke.test_simple_bug.TestSimpleBug testMethod=test_bug_resolution_flow>

    def setUp(self):
        """Set up the test environment with a project structure"""
        self.test_dir = Path("test_project")
        if not self.test_dir.exists():
            self.test_dir.mkdir()

        # Create a simple test project
        self._create_test_project()

        # Initialize engine and monitor
        self.engine = TriangulumEngine(config={"llm": {"provider": "mock"}})
>       self.monitor = EngineMonitor(self.engine)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^

triangulum_lx/tests/smoke/test_simple_bug.py:44:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <triangulum_lx.core.monitor.EngineMonitor object at 0x7fd04024c050>
engine = <triangulum_lx.core.engine.TriangulumEngine object at 0x7fd04024c0e0>

    def __init__(self, engine):
        self.engine = engine
>       self.H0_bits = log2(len(engine.bugs)) if len(engine.bugs) > 0 else 0
                                                     ^^^^^^^^^^^
E       AttributeError: 'TriangulumEngine' object has no attribute 'bugs'

triangulum_lx/core/monitor.py:384: AttributeError
=============================== warnings summary ===============================
triangulum_lx/tooling/test_runner.py:15
  /app/triangulum_lx/tooling/test_runner.py:15: DeprecationWarning: The 'triangulum_lx.tooling.fs_ops' module is deprecated and will be removed. Please import from 'triangulum_lx.utils.file_ops' instead.
    from triangulum_lx.tooling.fs_ops import atomic_write, atomic_delete

triangulum_lx/agents/test_message_bus.py:19
  /app/triangulum_lx/agents/test_message_bus.py:19: PytestCollectionWarning: cannot collect test class 'TestEnhancedMessageBus' because it has a __init__ constructor (from: tests/test_agentic_system.py)
    class TestEnhancedMessageBus(EnhancedMessageBus):

triangulum_lx/tooling/test_runner.py:18
  /app/triangulum_lx/tooling/test_runner.py:18: PytestCollectionWarning: cannot collect test class 'TestResult' because it has a __init__ constructor (from: tests/test_repair_workflow.py)
    class TestResult:

tests/unit/test_base_agent.py:21
  /app/tests/unit/test_base_agent.py:21: PytestCollectionWarning: cannot collect test class 'TestAgent' because it has a __init__ constructor (from: tests/unit/test_base_agent.py)
    class TestAgent(BaseAgent):

triangulum_lx/tooling/test_runner.py:18
  /app/triangulum_lx/tooling/test_runner.py:18: PytestCollectionWarning: cannot collect test class 'TestResult' because it has a __init__ constructor (from: tests/unit/test_patcher_agent.py)
    class TestResult:

triangulum_lx/agents/test_message_bus.py:19
  /app/triangulum_lx/agents/test_message_bus.py:19: PytestCollectionWarning: cannot collect test class 'TestEnhancedMessageBus' because it has a __init__ constructor (from: triangulum_lx/agents/test_message_bus.py)
    class TestEnhancedMessageBus(EnhancedMessageBus):

triangulum_lx/tooling/test_runner.py:18
  /app/triangulum_lx/tooling/test_runner.py:18: PytestCollectionWarning: cannot collect test class 'TestResult' because it has a __init__ constructor (from: triangulum_lx/tooling/test_runner.py)
    class TestResult:

triangulum_lx/tooling/test_runner.py:26
  /app/triangulum_lx/tooling/test_runner.py:26: PytestCollectionWarning: cannot collect test class 'TestRunner' because it has a __init__ constructor (from: triangulum_lx/tooling/test_runner.py)
    class TestRunner:

tests/integration/test_folder_healing.py::TestFolderHealing::test_folder_healing_dry_run
  /app/tests/integration/test_folder_healing.py:211: RuntimeWarning: coroutine 'BaseAgent.handle_message' was never awaited
    self.orchestrator.handle_message(message)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/test_startup_sequence.py::test_successful_startup
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_startup_sequence.py::test_successful_startup returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_startup_sequence.py::test_error_recovery
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_startup_sequence.py::test_error_recovery returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_startup_sequence.py::test_parallel_vs_sequential
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_startup_sequence.py::test_parallel_vs_sequential returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_startup_sequence.py::test_component_dependencies
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_startup_sequence.py::test_component_dependencies returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/unit/test_agent_message.py::TestMessageBus::test_broadcast_message
  /app/tests/unit/test_agent_message.py:452: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(message)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_agent_message.py::TestMessageBus::test_conversation_management
  /app/tests/unit/test_agent_message.py:541: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(message1)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_agent_message.py::TestMessageBus::test_conversation_management
  /app/tests/unit/test_agent_message.py:542: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(message2)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_agent_message.py::TestMessageBus::test_direct_message_delivery
  /app/tests/unit/test_agent_message.py:427: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(message)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_agent_message.py::TestMessageBus::test_message_type_filtering
  /app/tests/unit/test_agent_message.py:471: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(message)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_agent_message.py::TestMessageBus::test_unsubscribe
  /app/tests/unit/test_agent_message.py:499: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(message1)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_base_agent.py::TestBaseAgent::test_handle_message_error
  /app/tests/unit/test_base_agent.py:146: RuntimeWarning: coroutine 'BaseAgent.handle_message' was never awaited
    self.agent.handle_message(message)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_base_agent.py::TestBaseAgent::test_handle_message_query
  /app/tests/unit/test_base_agent.py:123: RuntimeWarning: coroutine 'BaseAgent.handle_message' was never awaited
    self.agent.handle_message(message)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_base_agent.py::TestBaseAgent::test_handle_message_status
  /app/tests/unit/test_base_agent.py:160: RuntimeWarning: coroutine 'BaseAgent.handle_message' was never awaited
    self.agent.handle_message(message)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_base_agent.py::TestBaseAgent::test_handle_message_task_request
  /app/tests/unit/test_base_agent.py:102: RuntimeWarning: coroutine 'BaseAgent.handle_message' was never awaited
    self.agent.handle_message(message)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_bug_detector_agent.py::TestBugDetectorAgent::test_analyze_test_failure
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/re/_compiler.py:220: RuntimeWarning: coroutine 'BaseAgent.send_response' was never awaited
    emit(op)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_bug_detector_agent.py::TestBugDetectorAgent::test_error_handling
  /app/triangulum_lx/agents/bug_detector_agent.py:2495: RuntimeWarning: coroutine 'BaseAgent.send_response' was never awaited
    self.send_response(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_bug_detector_agent.py::TestBugDetectorAgent::test_error_response_in_message_handling
  /app/triangulum_lx/agents/bug_detector_agent.py:2154: RuntimeWarning: coroutine 'BaseAgent.send_response' was never awaited
    self.send_response(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_bug_detector_agent.py::TestBugDetectorAgent::test_handle_query_get_bug_patterns
  /app/triangulum_lx/agents/bug_detector_agent.py:2406: RuntimeWarning: coroutine 'BaseAgent.send_response' was never awaited
    self.send_response(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_bug_detector_agent.py::TestBugDetectorAgent::test_handle_task_request_detect_bugs
  /app/triangulum_lx/agents/bug_detector_agent.py:2194: RuntimeWarning: coroutine 'BaseAgent.send_response' was never awaited
    self.send_response(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_circuit_breaker
  /app/tests/unit/test_enhanced_message_bus.py:308: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(response)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_cleanup_old_conversations
  /app/tests/unit/test_enhanced_message_bus.py:529: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(message)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_conversation_memory
  /app/tests/unit/test_enhanced_message_bus.py:431: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(query)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_conversation_memory
  /app/tests/unit/test_enhanced_message_bus.py:432: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(response)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_conversation_memory
  /app/tests/unit/test_enhanced_message_bus.py:433: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(follow_up)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_delivery_status_tracking
  /app/tests/unit/test_enhanced_message_bus.py:510: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(self.test_message)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_message_deduplication
  /app/tests/unit/test_enhanced_message_bus.py:397: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(self.test_message)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_message_deduplication
  /app/tests/unit/test_enhanced_message_bus.py:398: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(self.test_message)  # Duplicate
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_message_filtering_by_confidence
  /app/tests/unit/test_enhanced_message_bus.py:209: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(high_confidence_message)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_message_filtering_by_confidence
  /app/tests/unit/test_enhanced_message_bus.py:210: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(low_confidence_message)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_message_filtering_by_source
  /app/tests/unit/test_enhanced_message_bus.py:172: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(message_from_specific)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_message_filtering_by_source
  /app/tests/unit/test_enhanced_message_bus.py:173: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(message_from_other)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_message_filtering_by_topic
  /app/tests/unit/test_enhanced_message_bus.py:137: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(message_with_topic)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_message_filtering_by_topic
  /app/tests/unit/test_enhanced_message_bus.py:138: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(message_with_other_topic)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_performance_metrics
  /app/tests/unit/test_enhanced_message_bus.py:484: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(self.test_message)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_priority_based_delivery
  /app/tests/unit/test_enhanced_message_bus.py:259: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_priority_based_delivery
  /app/tests/unit/test_enhanced_message_bus.py:264: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_priority_based_delivery
  /app/tests/unit/test_enhanced_message_bus.py:269: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_thought_chain_integration
  /app/tests/unit/test_enhanced_message_bus.py:465: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    message_bus_with_tc.publish(self.test_message)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_unsubscribe
  /app/tests/unit/test_enhanced_message_bus.py:81: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    self.message_bus.publish(self.test_message)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_feedback_collector.py::TestFeedbackCollector::test_export_feedback_json
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/mock.py:2217: RuntimeWarning: coroutine 'EnhancedMessageBus.publish' was never awaited
    def __init__(self, name, parent):
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_fs_ops.py::test_parallel_atomic_writes_no_stale_reads[True]
tests/unit/test_fs_ops.py::test_parallel_atomic_writes_no_stale_reads[True]
tests/unit/test_fs_ops.py::test_parallel_atomic_writes_no_stale_reads[True]
tests/unit/test_fs_ops.py::test_parallel_atomic_writes_no_stale_reads[True]
tests/unit/test_fs_ops.py::test_parallel_atomic_writes_no_stale_reads[False]
tests/unit/test_fs_ops.py::test_parallel_atomic_writes_no_stale_reads[False]
tests/unit/test_fs_ops.py::test_parallel_atomic_writes_no_stale_reads[False]
tests/unit/test_fs_ops.py::test_parallel_atomic_writes_no_stale_reads[False]
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/multiprocessing/popen_fork.py:66: DeprecationWarning: This process (pid=48394) is multi-threaded, use of fork() may lead to deadlocks in the child.
    self.pid = os.fork()

tests/unit/test_implementation_agent.py::TestImplementationAgent::test_apply_implementation
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_apply_implementation
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_implement_null_pointer_strategy
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_implement_resource_leak_strategy
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_implement_resource_leak_strategy
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_implement_resource_leak_strategy
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_rollback_implementation
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_validation_failure_handling
  /app/triangulum_lx/agents/implementation_agent.py:778: DeprecationWarning: ast.Num is deprecated and will be removed in Python 3.14; use ast.Constant instead
    if isinstance(value_node, ast.Num):

tests/unit/test_implementation_agent.py::TestImplementationAgent::test_apply_implementation
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_apply_implementation
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_implement_null_pointer_strategy
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_implement_resource_leak_strategy
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_implement_resource_leak_strategy
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_implement_resource_leak_strategy
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_rollback_implementation
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_validation_failure_handling
  /app/triangulum_lx/agents/implementation_agent.py:780: DeprecationWarning: ast.Str is deprecated and will be removed in Python 3.14; use ast.Constant instead
    elif isinstance(value_node, ast.Str):

tests/unit/test_implementation_agent.py::TestImplementationAgent::test_apply_implementation
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_apply_implementation
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_implement_null_pointer_strategy
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_implement_resource_leak_strategy
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_implement_resource_leak_strategy
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_implement_resource_leak_strategy
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_rollback_implementation
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_validation_failure_handling
  /app/triangulum_lx/agents/implementation_agent.py:790: DeprecationWarning: ast.NameConstant is deprecated and will be removed in Python 3.14; use ast.Constant instead
    elif isinstance(value_node, ast.NameConstant) and value_node.value is None:

tests/unit/test_implementation_agent.py::TestImplementationAgent::test_apply_implementation
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_implement_null_pointer_strategy
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_implement_resource_leak_strategy
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_implement_resource_leak_strategy
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_implement_resource_leak_strategy
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_rollback_implementation
tests/unit/test_implementation_agent.py::TestImplementationAgent::test_validation_failure_handling
  /app/triangulum_lx/agents/implementation_agent.py:792: DeprecationWarning: ast.NameConstant is deprecated and will be removed in Python 3.14; use ast.Constant instead
    elif isinstance(value_node, ast.NameConstant):

tests/unit/test_priority_analyzer_agent.py::TestPriorityAnalyzerAgent::test_handle_priority_analysis_request
  /app/tests/unit/test_priority_analyzer_agent.py:42: RuntimeWarning: coroutine 'BaseAgent.handle_message' was never awaited
    self.agent.handle_message(message)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_strategy_agent.py::TestStrategyAgent::test_handle_error_messages
  /app/triangulum_lx/agents/strategy_agent.py:1048: RuntimeWarning: coroutine 'BaseAgent.send_response' was never awaited
    self.send_response(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_strategy_agent.py::TestStrategyAgent::test_handle_other_message
  /app/triangulum_lx/agents/strategy_agent.py:1158: RuntimeWarning: coroutine 'BaseAgent._handle_other_message' was never awaited
    super()._handle_other_message(message)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_strategy_agent.py::TestStrategyAgent::test_handle_query_get_strategy_templates
  /app/triangulum_lx/agents/strategy_agent.py:1080: RuntimeWarning: coroutine 'BaseAgent.send_response' was never awaited
    self.send_response(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_strategy_agent.py::TestStrategyAgent::test_handle_task_request_formulate_strategy
  /app/triangulum_lx/agents/strategy_agent.py:990: RuntimeWarning: coroutine 'BaseAgent.send_response' was never awaited
    self.send_response(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/unit/test_timeout_handling.py::TestBaseAgentTimeoutHandling::test_timeout_checking
  /app/triangulum_lx/agents/base_agent.py:876: RuntimeWarning: coroutine 'BaseAgent.send_message' was never awaited
    self.broadcast_status(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

triangulum_lx/tests/unit/test_transition.py::TestTransition::test_phase_transitions
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/case.py:589: RuntimeWarning: coroutine 'TestTransition.test_phase_transitions' was never awaited
    if method() is not None:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

triangulum_lx/tests/unit/test_transition.py::TestTransition::test_phase_transitions
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/case.py:690: DeprecationWarning: It is deprecated to return a value that is not None from a test case (<bound method TestTransition.test_phase_transitions of <triangulum_lx.tests.unit.test_transition.TestTransition testMethod=test_phase_transitions>>)
    return self.run(*args, **kwds)

triangulum_lx/tests/unit/test_transition.py::TestTransition::test_terminal_states
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/case.py:589: RuntimeWarning: coroutine 'TestTransition.test_terminal_states' was never awaited
    if method() is not None:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

triangulum_lx/tests/unit/test_transition.py::TestTransition::test_terminal_states
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/case.py:690: DeprecationWarning: It is deprecated to return a value that is not None from a test case (<bound method TestTransition.test_terminal_states of <triangulum_lx.tests.unit.test_transition.TestTransition testMethod=test_terminal_states>>)
    return self.run(*args, **kwds)

triangulum_lx/tests/unit/test_transition.py::TestTransition::test_timer_countdown
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/case.py:589: RuntimeWarning: coroutine 'TestTransition.test_timer_countdown' was never awaited
    if method() is not None:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

triangulum_lx/tests/unit/test_transition.py::TestTransition::test_timer_countdown
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/case.py:690: DeprecationWarning: It is deprecated to return a value that is not None from a test case (<bound method TestTransition.test_timer_countdown of <triangulum_lx.tests.unit.test_transition.TestTransition testMethod=test_timer_countdown>>)
    return self.run(*args, **kwds)

triangulum_lx/tests/unit/test_transition.py::TestTransition::test_wait_stays_waiting
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/case.py:589: RuntimeWarning: coroutine 'TestTransition.test_wait_stays_waiting' was never awaited
    if method() is not None:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

triangulum_lx/tests/unit/test_transition.py::TestTransition::test_wait_stays_waiting
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/case.py:690: DeprecationWarning: It is deprecated to return a value that is not None from a test case (<bound method TestTransition.test_wait_stays_waiting of <triangulum_lx.tests.unit.test_transition.TestTransition testMethod=test_wait_stays_waiting>>)
    return self.run(*args, **kwds)

triangulum_lx/tests/unit/test_transition.py::TestTransition::test_wait_to_repro
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/case.py:589: RuntimeWarning: coroutine 'TestTransition.test_wait_to_repro' was never awaited
    if method() is not None:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

triangulum_lx/tests/unit/test_transition.py::TestTransition::test_wait_to_repro
  /home/jules/.pyenv/versions/3.12.11/lib/python3.12/unittest/case.py:690: DeprecationWarning: It is deprecated to return a value that is not None from a test case (<bound method TestTransition.test_wait_to_repro of <triangulum_lx.tests.unit.test_transition.TestTransition testMethod=test_wait_to_repro>>)
    return self.run(*args, **kwds)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/integration/test_folder_healing.py::TestFolderHealing::test_folder_healing_dry_run
FAILED tests/integration/test_folder_healing.py::TestFolderHealing::test_orchestrator_real_healing_simulation
FAILED tests/integration/test_system_startup_integration.py::TestSystemStartupIntegration::test_graceful_shutdown
FAILED tests/integration/test_system_startup_integration.py::TestSystemStartupIntegration::test_startup_dashboard_integration
FAILED tests/integration/test_system_startup_integration.py::TestSystemStartupIntegration::test_system_health_monitoring
FAILED tests/unit/test_agent_message.py::TestMessageBus::test_broadcast_message
FAILED tests/unit/test_agent_message.py::TestMessageBus::test_conversation_management
FAILED tests/unit/test_agent_message.py::TestMessageBus::test_direct_message_delivery
FAILED tests/unit/test_agent_message.py::TestMessageBus::test_message_type_filtering
FAILED tests/unit/test_agent_message.py::TestMessageBus::test_unsubscribe - A...
FAILED tests/unit/test_base_agent.py::TestBaseAgent::test_broadcast_status - ...
FAILED tests/unit/test_base_agent.py::TestBaseAgent::test_handle_message_error
FAILED tests/unit/test_base_agent.py::TestBaseAgent::test_handle_message_query
FAILED tests/unit/test_base_agent.py::TestBaseAgent::test_handle_message_status
FAILED tests/unit/test_base_agent.py::TestBaseAgent::test_handle_message_task_request
FAILED tests/unit/test_base_agent.py::TestBaseAgent::test_no_message_bus - As...
FAILED tests/unit/test_base_agent.py::TestBaseAgent::test_send_message - Asse...
FAILED tests/unit/test_base_agent.py::TestBaseAgent::test_send_response - Ass...
FAILED tests/unit/test_bug_detector_agent.py::TestBugDetectorAgent::test_error_handling
FAILED tests/unit/test_bug_detector_agent.py::TestBugDetectorAgent::test_error_response_in_message_handling
FAILED tests/unit/test_bug_detector_agent.py::TestBugDetectorAgent::test_handle_query_get_bug_patterns
FAILED tests/unit/test_bug_detector_agent.py::TestBugDetectorAgent::test_handle_task_request_detect_bugs
FAILED tests/unit/test_bug_detector_enhancements.py::TestBugDetectorEnhancements::test_bug_classification
FAILED tests/unit/test_bug_detector_enhancements.py::TestBugDetectorEnhancements::test_context_aware_detection
FAILED tests/unit/test_bug_detector_enhancements.py::TestBugDetectorEnhancements::test_false_positive_reduction
FAILED tests/unit/test_bug_detector_enhancements.py::TestBugDetectorEnhancements::test_folder_analysis_performance
FAILED tests/unit/test_bug_detector_enhancements.py::TestBugDetectorEnhancements::test_relationship_integration
FAILED tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_circuit_breaker
FAILED tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_cleanup_old_conversations
FAILED tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_conversation_memory
FAILED tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_delivery_status_tracking
FAILED tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_direct_message
FAILED tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_large_message_handling
FAILED tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_message_deduplication
FAILED tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_message_filtering_by_confidence
FAILED tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_message_filtering_by_source
FAILED tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_message_filtering_by_topic
FAILED tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_performance_metrics
FAILED tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_priority_based_delivery
FAILED tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_subscribe_and_publish
FAILED tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_thought_chain_integration
FAILED tests/unit/test_enhanced_message_bus.py::TestEnhancedMessageBus::test_timeout_handling
FAILED tests/unit/test_feedback_collector.py::TestFeedbackCollector::test_analyze_feedback
FAILED tests/unit/test_feedback_collector.py::TestFeedbackCollector::test_export_feedback_json
FAILED tests/unit/test_fs_ops.py::test_fsync_mocked - AttributeError: module ...
FAILED tests/unit/test_priority_analyzer_agent.py::TestPriorityAnalyzerAgent::test_analyze_priorities
FAILED tests/unit/test_priority_analyzer_agent.py::TestPriorityAnalyzerAgent::test_handle_priority_analysis_request
FAILED tests/unit/test_relationship_analyst_agent.py::TestRelationshipAnalystAgent::test_analyze_codebase
FAILED tests/unit/test_relationship_analyst_agent.py::TestRelationshipAnalystAgent::test_error_handling
FAILED tests/unit/test_relationship_analyst_agent.py::TestRelationshipAnalystAgent::test_find_cycles
FAILED tests/unit/test_relationship_analyst_agent.py::TestRelationshipAnalystAgent::test_get_file_dependencies
FAILED tests/unit/test_relationship_analyst_agent.py::TestRelationshipAnalystAgent::test_get_file_dependents
FAILED tests/unit/test_relationship_analyst_agent.py::TestRelationshipAnalystAgent::test_get_impacted_files
FAILED tests/unit/test_relationship_analyst_agent.py::TestRelationshipAnalystAgent::test_handle_query_central_files
FAILED tests/unit/test_relationship_analyst_agent.py::TestRelationshipAnalystAgent::test_handle_query_file_dependencies
FAILED tests/unit/test_relationship_analyst_agent.py::TestRelationshipAnalystAgent::test_handle_task_request_analyze_codebase
FAILED tests/unit/test_relationship_analyst_agent.py::TestRelationshipAnalystAgent::test_prioritize_files_for_repair
FAILED tests/unit/test_relationship_analyst_agent.py::TestRelationshipAnalystAgent::test_process_message
FAILED tests/unit/test_response_handling.py::TestResponseHandling::test_chunking_and_reassembly
FAILED tests/unit/test_response_handling.py::TestResponseHandling::test_large_response_handler
FAILED tests/unit/test_response_handling.py::TestResponseHandling::test_validation
FAILED tests/unit/test_strategy_agent.py::TestStrategyAgent::test_handle_error_messages
FAILED tests/unit/test_strategy_agent.py::TestStrategyAgent::test_handle_query_get_strategy_templates
FAILED tests/unit/test_strategy_agent.py::TestStrategyAgent::test_handle_task_request_formulate_strategy
FAILED tests/unit/test_system_monitor.py::TestSystemMonitor::test_check_health
FAILED tests/unit/test_system_monitor.py::TestSystemMonitor::test_export_metrics
FAILED tests/unit/test_timeout_handling.py::TestOrchestratorTimeoutHandling::test_orchestrator_timeout_handling
FAILED triangulum_lx/tests/smoke/test_simple_bug.py::TestSimpleBug::test_bug_resolution_flow
===== 68 failed, 353 passed, 5 skipped, 104 warnings in 103.56s (0:01:43) ======
